'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var ReactDOM = _interopDefault(require('react-dom'));

const initialGameState = {
    player: "Demo",
    game: {
        nextFenString: "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
        nextPlayerTurn: "White",
        movePieceFrom: "",
        movePieceTo: ""
    },
    resetGame: false
};
const defaultGameState = {
    getGameState: initialGameState,
    setGameState: () => { }
};
const GameContext = React.createContext(defaultGameState);

class GameData {
    constructor() {
        this.attackedSquaresArray = [];
        this.capturedPiecesArray = [];
        this.numberOfValidMoves = 0;
    }
    incrementValidMoveCount() { this.numberOfValidMoves++; }
    clearAttackedSquares() { this.attackedSquaresArray = []; }
    resetValidMoveCount() { this.numberOfValidMoves = 0; }
    getAttackedSquares() { return this.attackedSquaresArray; }
    getCapturedPieces() { return this.capturedPiecesArray; }
    getNumberOfValidMoves() { return this.numberOfValidMoves; }
    setAttackedSquare(square) { this.attackedSquaresArray.push(square); }
    setCapturedPiece(piece) { this.capturedPiecesArray.push(piece); }
}

class GameState {
    getMoveState() {
        const prevMove = this.previousActivePiecePos;
        const nextMove = this.nextActivePiecePos;
        return { prevMove, nextMove };
    }
    getFenString() { return this.fenString; }
    getCurrentTurn() { return this.currentTurn; }
    getFenCastlingState() { return this.fenCastlingState; }
    getHalfmoveClock() { return this.halfmoveClock; }
    getFullmoveClock() { return this.fullmoveClock; }
    setMoveState(prev, next) {
        this.previousActivePiecePos = prev;
        this.nextActivePiecePos = next;
    }
    setFenString(fen) { this.fenString = fen; }
    setCurrentTurn(player) { this.currentTurn = player; }
    setFenCastlingState(fen) { this.fenCastlingState = fen; }
    setHalfmoveClock(move) { this.halfmoveClock = move; }
    setFullmoveClock(move) { this.fullmoveClock = move; }
}

var whitePawn = "data:image/png;base64,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";

var whiteKnight = "data:image/png;base64,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";

var whiteBishop = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAH8AAACACAYAAAAiebbfAAAACXBIWXMAAAPnAAAD5wHDtfxxAAAMxklEQVR4nO1dT2gUTRZ/vSwICiYXhZWIOXgQFZyVRdFLElDibfOp6PFLRM+OxLNG75LJWTHZo6ISbwaFTS4KHtwEVOJpDUr26gjf3qSW3+wraburuntmerpe1cwPmmjPv+7+vXr16v2rSClF/YAoioaJaIqPGhEdiN32FhGt4lBKLfXFA8Ez6QfyoyiaI6I6EQ0VeDsEYa4fhCBo8qMoGiWiZSI61sHHnxPRtFLqWw8uTQSCJT+Kohqr8iKj3YYNIhoPVQD+JOAaSgfP70tdEk+sMZYF3mIpCJJ8zNk2VT85OUkPHz6k7e3t1rG5uUnz8/N06tQp23eNRVFU7+nVOkJwap/n+X8nz+/evZsajQadO3fO+tn79+/T7du3TS81iWg0NPUfIvlQ978nz798+ZKOHDmS+/lHjx7RjRs3TC/NhLYCCFHtjydPzM7OFiIeuHz5sm0KmC7h2kQhKPJZ5R9Inr906VJb33Pt2jXT6bEuLk0kQhv5o8kThw8fpv3797f1JTa7gFcRwSBUa/8nhoY6W+1BaAyolX+F7hA8+Z3i69evpk9+9uLiCyJ48j98+ND2Z758+ULfv39PnVdKDciXCqXUavLSQCKWb+3g8ePHpndvhPSsKNCR/zx54t69e8aRbAJGPZw9BqQEy3eESH7KF4/5+/z587kCgNdnZmZs72uUeI0iEBz57IVLqeiPHz/SmTNn6PXr18bPYWo4ceJE630G/CO0+Z5CDelyOPdfttdHRkZaHr+jR4/S+/fv6c2bN1laAX792oB8jxBFEdyxiyVc8YTJkAwBwS71WP3PdPEVGPG/hUo8hUw+u2Lh7v2jw6/4LxEF5c5NIsSQ7jAnaxZN2MxDsAmdQZHP83yjCOk7duygPXv22Ny4JkAI6kqpcNK6QL7vB8fw13E7ecfIyIian59Xm5ubant7u/V3dna2db7I59nZMxrCc/N65LOKR77e9bz3IkEDSR2nT5+2vgdrfbh2sfTLAYzBhlJqrtQbqhjekh9F0Thn6KaSN+IoQnoScATBJVxACOBMmvLVB+Al+VyBY8y01OiE9CRevHhBt27dyrMLmmwLeGcQekU+q/nlrJQqeO/u3r2bmaXbLhDoKRAcggvYqzw/b8hnl+1SVunV1atX6ebNm6007bIB4q9fv04rKytZ3+xVhY8X5OeVXmG0Iye/GxVfFJgK6vV6lhbY4Bq/9Z5fTJcQT34URVNZpVfIzIWa78Vot0GHfjMMwiZrANECIJr8vOAMyqyQZ+8KMAYfPHhg+3XxAiCW/KywLEb506dPCxdi9BLwDaDEyzINiBYAkeRnzfFIqV5YWBBBvAaSRC9cuGATgC3OBxBnBIojn5dzn23EP3v2rNL5vShyBEDkKkBiSNc64qUSD0ATYSqyXN8xiTmAosiPoqhhWsfjgZZJPNy3hw4don379rXy9jrJ7TchRwB+ZwNWDMSoffbV/zN5vhfGHYiPq2e4gvEbZQG+gCtXrpi+TVQ+oIiRH2ujkgKcN2Ubd8l5uUAApy3AtYy4ggFDtvt0ASlqf84UnYO7tkwffZUA+ZY6/zEp6t+52re1UYGB9+rVq578Jub6JNCfp2xAw8CmMKwARLR5kTDyjVYw1vK+Q/cBMmCIcwydwin57Mz5e/I81L0kJ043wLRlUf91180eXI/8lPRjtCAsGxIQeDLA+eh3Rj7P9amuWeiHI9WR0ymgxSx9gZwafs4MPm5sOB8/B9Lfvn3bFflYY1tKrH/CtLTLaML4Uxt1MxWh9PvkyZOml35zlQ7ukvzPyeUdRofFQCoEPOCzZ88WrsVvB0gYgWB2A/j+DYL3XCk1VfoFF4ATtc+GXmpdb2mBVhi2diplAEmc3bqBLao/ZfBWBVdzfqpRItb13Vr4nXbeKop2W7olgcQT05TG2UqVwxX5qZstI/8OwoNlYtkAYcgaKsMQtdgWqcFQBZzM+VEUfUuGbZ88eVJaAiZUP5ou2HDx4sXUK/h9G8pMDLX09l1TSlUuAJWTb3Pn9sK9akNV7l0TYDfAKE1CKRVVcgExuFD7qRapWcus0GCza3hQVAoX5KfUW2hOnTxYhL0vyE8BjZEGqL4LyKD3rgNYVH/lTZ0H5DtAr/0RRTEgn123/Yi+JD/pCLLk2/UMcENLwJ9FXEXFQHwdrlY4guDA6dZt2y4s5Ffe78/FyE/lrdn64fYSMLogAFUTT4JGvgvyU0WLUh5GFYDr2dLmpfJiThHk42H0iwBYtFzTRSZv5eTzTW4lz7tQ/S5guU8n/X1dWfuptCXL1ibBAWlmBvQV+ambRXpT6Kof4VzLfO8kh88J+ZywmFL9aHcWMizabc1V4aZLJ0+qYBEPp6xyaWnAqLcUhDor3HSZvWvswNHLGj1XyKjZ21JKVR7K1XA28tnqT+VpY4Mj9LkLCRk7djlt3Ozat98wzf1Q/3mFF74AgmxR92uu+/VKKNE2duQgDsBY6tzEAyMdffosRp6IDh0i2rJwLx5jz3ykPC0uLnqV6gWjFX16LXv0ATMSunRL6smzZCrcJM7xQzWP9CJOvRVrRldOYEEpJcKoEdWHL0sAiIXg+PHjNDExIap+HzV8OFZXcx11otqyS2zCmCkAHuOGUkpULz6p7VcL75LlAZq8FYu4zRlFpnGxMVQzbYfuGRa48ZLIXTnF5vDxMsiLHSsyMCx51w3JLdetc//OnTvp4MGDtGvXruovLIFms0mfPn2iHz9+2N5yR+oWbFLnfOvuWS521shDgZ03RKzrk5Bo7Vs9ft22bek14MqV7NFLQlrXbWsPXunEE/cJtrReEdVzV0OawVc39erxgXgNXCfC0gaI6bmrIcm9a4zvo5QK8X2ffPtS4/dJSBr5xv3uMZJ8q9/H9d65c8f00gFJo18S+amHMjk5WclGib0AqoEsTRgG5Mdh68vnew9ei/E35qIFiwlSRn5qNJTRl881bH33XLVeS0JKlW7qYezduzeIVG54It+9e5c8PSVh6Sclk8e/Tfy7w3+UUul+cBXDudpnj16/4S8S7lfCnO90twlXkCD0EsivvAvVAP+HyLYsWB/7ur43IaNA0ylEkg/iq26S1EugJl8i+SIzefqpTYtLSCA/ld+W1S7dR1iSPJzH9iWQn3oIqHRBqVOvtkypCjrDxwQJiR1SnDypzZaIw7mY++Em9QkgHZU7OCwC7GxTpTikkG/N2SMWApRqYXdKF33zikKXayGVK0drOdtOLQ4vavXiwDIQQoAVgYTADyx5NFnC34zCzDgGtXom5GmAJBAxgzCgXz/+Qiv0UjOg+hajG39Bdpv77iOJsy4pi1di9m6NS7XGOv0OnUQRdxQV3coF5Oo1Of6tjy7X6c+ZeFHZu5KLNsa5bUnHQiAAIL0htVxLLPkarAnqHAP3oXBzi/vqNaSN9CTEkx8H7zw5zscxOVdGa+ysWlZKVd5AuVN4RX4cnOpdY0Go8e5UvRaIJjeO/sx/16Wq9CLwlvwkYsIA7fA3IvorajpL+Oo/mOgnMcJ9rx5uwYc5fzgR84//vxb7f9v2AJaKHbqQ4xpAz+u/aAAfNELX5MfIiZOSJCyOYdfzNTyGKAbBUhCxdiSKCgi5rmW8th7rVdASqjKEqy3yDfPsuE+tU1AEAjexKVEEQgC3bJuOG9fYYsHQxmZbq4tc8pnwaT4kWdiFoKt+MnLofwEcOnDXQhgKumslAdpjrqhWsJLPpNdtNXQSAXUOf79293abCgZ7AG5c7c4twdNXFQoJgZF89q4tmcKsLpB0zWpSMZJBNnaorDLIo7dK0VMEWrMkW8ULmT7gYZy2rU5S5EdRhJE+384vYMQhoKKJIN66zKZmQ0rOLAPQMLbsJbymBavDWEOTBSAVQv6F/CJh1WQkbUCkG2iBgX1SIH+ATN0/f5KfRzwqThFHx+E7tEGHBwaNhRWA70WhBZesG1ih6WmgRX6Wqke1LLpf+TzC40Yb5mLTKMHUhXvUWs1XYYAAZKSPUVwAIl6rW7tfFW17lpy38LDb9Z5p26ETxH+vrDg8BF8bk9qW6eYaO7kebdRqFBmE+J2MTR5IC0DEMfNU9kxWEyQ9gkA2fsjD9bD30JlLEAxbShu0QEaZ+4SxYgfSFp/bdeoS5kocvqdUhwAMvvjIhkbSuY049B4FGKArKyumO24VyGLkqz48lvne1/v0/ucy5/yA0Iz5wFt/444P9maOx2IWPqeOFUGrI6i29rH+WyzhSzdi0afPHZQkdVOz/i2xQ7d2bXYUf7dEKyl2roxrLIL4742W4HVtsrW/Hl/nt+vS1alLqyElOPgA7uZViyWvFA24bbC3ryWAJvfuNH9hMly7kQgfDsgWAhYGzVmyrR1GOjhb+sXFS0T/A4Gu9STlGBVuAAAAAElFTkSuQmCC";

var whiteRook = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAACACAYAAADamU0oAAAACXBIWXMAAARQAAAEUAGvFs/IAAAFo0lEQVR4Ae2dMUwjRxSG35BIJA1QkQjZCRHVGaSjQjHNpaQLkiW7zCWC3sgU6bDpUiBRUNBER7oDgZQOCgrS2KmiaxzR5YiRSDqChCKUYqJnfMqds7se78zs2s//J61Oul1m3sy3Ozs7s+shrXXkRkRTRFQlotdEpC23WyLa5TR75WsQ00EnPduYujcuZ9Umvk6Mi50YXcT0ioieG+VrENhzD5VmVWEOKypqM6rAiBhfeYhp1oXQCw+B3VpWlm+ZvF1YXp0+Yup5IYxROkymlG9STKWVcVpCgSfej5NsJpOhUqlkdGy9XqdGo+HdXz6fp+Xl5Vh/e3h4SNfX185j6qZYLFI2mzU6dmdnJ1YesYRyUJVKxfj4JISyzH5iehs+6ZISanrSxRWKJlcYsa5QFyilLga8KhctYkytU5SaUCJ6lmLeJkwOQYz/A02uMLwLnZ+fT6TGVlZWUvnbflhYWPCeh3ehXFn8mOOTXC5ndeKYPoLZwD3ciYkJ7/kkcg89Pz+n09NTOjo6cpouVxCfMLZCOJ3Ly8v28+jZ2Zmz+N6kzfEl1Qqozthj+AGPPb13Ogf8EH9ycuI7tpFmZmYmqPg1rXU1ql7QKRIGhAoDQoUBocKAUGHEemxptVqxZwOAX0weW66I6BN4GAheaK2/iQrEROg/KQ/ig/+40lrPRtWHyT30b1TowPBHr0BMhP4ipz6Gnpe9CtCzyaXHZvdXInoy6rWZMt9rrdd6hWAklB6l8svNXwXt4wFoHttNaqpMGjwpsLGxEVWqr7XWBybFNn4O1VrzG/Q/BO27u7ujQqFAzWZTds17wKVM6ndgAVLd4lomxRkpglQ3+JBJcYf+INUOXzLJZiwXUuPhUyb108sNTaBH73d3dzeRd2mGAT7Bt7a2oiK1ktnG9sPWBL/XlL5ZfY9q/H0opCayOZHpVCikxt6cyeTN+h7ajVKKP0V/6jRRuXyntf7WZel8vLHwo4c0peL2JeAk5zmPj4+TymrgMOjdOiMxoXG/rgb9gZfEhAGhwoBQYUCoMCBUGBAqDAgVBoQKA0KFAaHCgFBhQKgwIFQYECoMCBUGhAoDQoUBocKAUGFAqDAgVBgQKgwIFQaECgNChQGhwoBQYUCoMCBUGBAqDAgVBoQKA0KFAaHCgFBhQKgwIFQYECoMCBUGhAoDQoUBocJI7KfhQtaUBo7BFSoMH0I/GOkaTRkfQj8fqhpIl0XXuTv9RWulFK9t+ZuzBOXzp9b6Y5eldN0pClyiYm5ujlZXVx1nNVzs7e3Rw8NDd8wfKaWqWuuqq8I4E6qUYmPPgvbt7++P/MqFvHZNyK9al3ntG631axf5OLmHKqWmiGg3aN/a2trIy2TW19cpl8sF7ZoMq7s4uOoUlYno0+7/5LNyc3PTVaxDz/b2dlgRvlRKfeGifNZCOx2hwLakVqthmay34N/dLxaLYbvtlsjq4GLts4uge2c+n2+v+gvehRf6W1paav8bQM22g2R1hUZ1hCKal5GGW6xKpRJWBeVOixefmEti8Vn0O5a58rbx6lSriSyVpZTidUNfjPqVlhCf9fs4E6fJHe0RgmTpu67jCJ0asEJLpu+6xvSZMJwM/XHPDaNBdjQaDSfpOBHKMvHMaYerNzrQ5AoDQoUBocKAUGFAqDAgVBgQKgwIFQaECqM9fdZ5n6VsOBj8tPs4DP3ZEzL0d0VEJtNnfEz1zVRbGRPKYrbF94joJabExPDhWNDrl2BomUWnSBiB02eZTIay2WxoSe/v7+nm5iboWw3gAO5kTk9P0/j4eGhizWYz8FXQQKGlUinqVUMwABQKhcCeMZpcYUCoMCBUGBAqDAgVRmAvt16vj3q9DDytViswRNUZxwQy+AlNrjBY6F+jXgmCuB1z9Sk4GAgOePrsZ552IaIn+Fm3oYUnwmta64N/AfykFDKBoTEIAAAAAElFTkSuQmCC";

var whiteQueen = "data:image/png;base64,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";

var whiteKing = "data:image/png;base64,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";

var blackPawn = "data:image/png;base64,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";

var blackKnight = "data:image/png;base64,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";

var blackBishop = "data:image/png;base64,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";

var blackRook = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAACACAYAAADamU0oAAAACXBIWXMAAARQAAAEUAGvFs/IAAAFqElEQVR4nO2dPWgjRxTH35mAAwbZpEkmWPFdZ1BxThepSQg22FUMMnYZ58CdC4GbVP4oAxZ2b4OdUgIRFylcXlJYbQ5sdSY+pGiIIXDnzpXDXPaC0e2uRrtvVqu3/1+pXc2+md/u7Hzt7pOHhwcKQ2s9RUQVIlonopnQnfvzlohOiWhXKfUmaiJeTIdEtExEkzFj6uW1iVEptRsnEa31nFdu3zPE9MrkVyl12m9HG6FG5AlDUI/Zi1NgWutTpoIK4webAgyJ8Q8ies4c0zOl1E3YDmMWiazzxfM/lZj/dy2T4uTbuzq5ZZJNTDZCXcBdTaaNqWHFMyyhwBEfRUm20+lQrVaz2rdUKlGxWHTur9ls0sXFRaT/rq2t0fT0NHtMvdTrdWq321b7bm1tRTpGJKEmqGq1ar1/EkKNzEFieow56ZISanvSRRWKKlcYka5QDrTWL1NelHMxYhxao2hoQono6yEe24bJEYjxA1DlCsO50Kurq0RK7Pz8fCj/HYTLy0vnx3Au1BSW6ea4pNVqxTpxbLtgcTAt3Lu7O+fHSeQeOj8/T0tLS7S6usqarikgc8LEFWLSmZ2dfdcfXVxcZIvvfdomvqRqAZvB+Ze9jQPTiS+Xy65jyzTdbtcv+30nNdAoEgaECgNChQGhwoBQYUTqtuTz+cizAcAtNt0Ws2jqC3hIBSdKqRdhgdhUuZ/LKY+R59t+GcA9VBg2Qv/KeiGliF/7hdL3Hkr/3Uf/IaJPZJXNyPG7Uqrv/KyVUOqzuNkMQJux3aSmyqRhJgUODg7CcmW96Nv6HqqUMot8f/bblsvlqNFoUKFQkF3yDuCUSYM2iiCVF26ZFKWVC6k8uJBJUbstkBoPVzIpTj8UUqPhUiYN0soNol/rt1KpJLKWZhQwJ/je3l5YpLFkEodQSu55TenElklcQ39h1S+wgkUmcY7lQmpk2GQSV5X7GEePokvlJ6XUj5x5czHbcuYgTamwL9ZN7GGllZWVpA6VOixat2wkJjTq09VgMDDBLQwIFQaECgNChQGhwoBQYUCoMCBUGBAqDAgVBoQKA0KFAaHCgFBhQKgwIFQYECoMCBUGhAoDQoUBocKAUGFAqDAgVBgQKgwIFQaECgNChQGhwoBQYUCoMCBUGBAqDAgVBoQKA0KFAaHCgFBhQKgwIFQYECoMCBVGYq+GC/imNGAGV6gwXAj9ONMlOmRcCP1qpEpguMxxH531jdZa66dE9CdbgvL5Wyn1GWcuuRtFvu9Ov76+prOzbL/oenNzk8bHx3t//lRrvauU2uU6DtsVqrVeJqJf/LYtLCxk/suFGxsbQW+1fmuqXqXUDcdxWO6hWuspIjr023Z8fJx5mYajoyNqtVp+myaDyi4KXI2iChHN9P5ovqi0v7/PFevIs729HZSF77TW33DkL7ZQryG047dtZ2cHn8l6hHnvfr1eD9qcmg/x+AbSbDapVqsxJC8Lc5UGnOQzpoEUN7OxhHoNId/vQodUL5nGyKxWq0FFUPFqvMhEauV6Z9ILIspnXZAjXhGR6c4M3NcbWKjW2nzj7GS4+c0MzwbtzkSpcpezXsoJMnBZRxE6laYcC2fgssb0mTBYxnJNyw2jQfEoFoss6bAINTLL5TJHUpmFa0UHqlxhQKgwIFQYECoMCBUGhAoDQoUBocKAUGG8mz7z1rNULAeDn/fuh6G/+AQM/b0mIpvpsxtv/vTmSbfbNSIPUpY/EI0vx7wrE8igMua3/BKMLE/RKBKG7/RZp9OhdrsdmNOJiQlSSvk9qwEYMI3M29tbur+/D0ysUChQLpf74HdfoWY9bchSQ5ACGo2Gb8sYVa4wIFQYECoMCBUGhArDt5VbKpWyXi6pJ5/3f6zIjOXyvTUDDJvfUOUKY8x7aQOQwZsxrkfBQSo4NY2i94+Br3tv5ACjh5kIP1RKnf0LWOPEteXHWzcAAAAASUVORK5CYII=";

var blackQueen = "data:image/png;base64,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";

var blackKing = "data:image/png;base64,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";

const wP = whitePawn;
const wN = whiteKnight;
const wB = whiteBishop;
const wR = whiteRook;
const wQ = whiteQueen;
const wK = whiteKing;
const bP = blackPawn;
const bN = blackKnight;
const bB = blackBishop;
const bR = blackRook;
const bQ = blackQueen;
const bK = blackKing;
class Pieces {
    constructor() {
        this.pieceImages = new Map();
        this.initialise();
    }
    initialise() {
        this.setChessPieceImgs();
    }
    setChessPieceImgs() {
        this.pieceImages
            .set('p', bP).set('n', bN).set('b', bB).set('r', bR).set('q', bQ).set('k', bK)
            .set('P', wP).set('N', wN).set('B', wB).set('R', wR).set('Q', wQ).set('K', wK);
    }
    pawnMoves(colour) {
        const validDirections = new Map();
        if (colour === 'P') {
            validDirections.set('N', 2).set('NE', 1).set('NW', 1);
        }
        else {
            validDirections.set('S', 2).set('SE', 1).set('SW', 1);
        }
        return validDirections;
    }
    knightMoves() {
        const validDirections = new Map();
        validDirections.set('NNE', 1).set('ENE', 1).set('ESE', 1).set('SSE', 1).set('SSW', 1).set('WSW', 1).set('WNW', 1).set('NWN', 1);
        return validDirections;
    }
    bishopMoves() {
        const validDirections = new Map();
        validDirections.set('NE', 8).set('SE', 8).set('SW', 8).set('NW', 8);
        return validDirections;
    }
    rookMoves() {
        const validDirections = new Map();
        validDirections.set('N', 8).set('E', 8).set('S', 8).set('W', 8);
        return validDirections;
    }
    queenMoves() {
        const validDirections = new Map();
        validDirections.set('N', 8).set('NE', 8).set('E', 8).set('SE', 8).set('S', 8).set('SW', 8).set('W', 8).set('NW', 8);
        return validDirections;
    }
    kingMoves() {
        const validDirections = new Map();
        validDirections.set('N', 1).set('NE', 1).set('E', 1).set('SE', 1).set('S', 1).set('SW', 1).set('W', 1).set('NW', 1);
        return validDirections;
    }
    generalDefence() {
        const generalDirections = new Map();
        generalDirections.set('N', 8).set('NE', 8).set('E', 8).set('SE', 8).set('S', 8).set('SW', 8).set('W', 8).set('NW', 8);
        return generalDirections;
    }
    knightDefence() {
        const validDirections = new Map();
        validDirections.set('NNE', 1).set('ENE', 1).set('ESE', 1).set('SSE', 1).set('SSW', 1).set('WSW', 1).set('WNW', 1).set('NWN', 1);
        return validDirections;
    }
    getChessPieceImgs() { return this.pieceImages; }
}

class Rook {
    constructor(type, colour, image) {
        this.type = type;
        this.colour = colour;
        this.image = image;
        this.initialise();
    }
    initialise() {
        this.moves = 0;
        const pieces = new Pieces();
        this.castled = true;
        this.setMoveDirections(pieces.rookMoves());
    }
    incrementMoveCount() {
        this.moves += 1;
        this.setCastledStatus(false);
    }
    canCastle() { return this.castled; }
    getType() { return this.type; }
    getColour() { return this.colour; }
    getImage() { return this.image; }
    getMoveDirections() { return this.moveDirections; }
    getMoveCount() { return this.moves; }
    getPosition() { return this.position; }
    getStartingSquare() { return this.startingSquare; }
    setImage(image) { this.image = image; }
    setMoveDirections(directions) { this.moveDirections = directions; }
    setPosition(pos) { this.position = pos; }
    setStartingSquare(square) { this.startingSquare = square; }
    setCastledStatus(castled) { this.castled = castled; }
}

class Pawn {
    constructor(type, colour, image) {
        this.type = type;
        this.colour = colour;
        this.image = image;
        this.initialise();
    }
    initialise() {
        this.upgraded = false;
        this.moves = 0;
        const pieces = new Pieces();
        this.setMoveDirections(pieces.pawnMoves(this.type));
    }
    update() {
        if (!this.firstMove) {
            this.firstMove = true;
            if (this.type === 'P') {
                this.moveDirections.set('N', 1);
            }
            else {
                this.moveDirections.set('S', 1);
            }
        }
    }
    incrementMoveCount() {
        this.moves += 1;
        this.update();
    }
    hasUpgraded() { return this.upgraded; }
    getType() { return this.type; }
    getColour() { return this.colour; }
    getImage() { return this.image; }
    getMoveDirections() { return this.moveDirections; }
    getPosition() { return this.position; }
    getMoveCount() { return this.moves; }
    getStartingSquare() { return this.startingSquare; }
    setImage(image) { this.image = image; }
    setMoveDirections(directions) { this.moveDirections = directions; }
    setPosition(pos) { this.position = pos; }
    setStartingSquare(square) { this.startingSquare = square; }
    setHasUpgraded(upgraded) { this.upgraded = upgraded; }
}

class SpecialMoveHandler {
    constructor(gameData, chessboard) {
        this.gameData = gameData;
        this.chessboard = chessboard;
    }
    determineEnPassantSquare(enPassantSquare) {
        if (enPassantSquare !== "-") {
            const squaresArray = this.chessboard.getSquaresArray();
            const files = this.chessboard.getFiles();
            const pos = enPassantSquare;
            let file = files.indexOf(pos[0]);
            const rank = Number(pos[1]);
            const targetSquareIndex = this.calculateArrayIndex(file, rank);
            squaresArray[targetSquareIndex].setEnPassantSquare(true);
            this.chessboard.setEnPassantSquare(squaresArray[targetSquareIndex]);
        }
    }
    enPassantOpeningDeterminant(attackedSquare) {
        const squaresArray = this.chessboard.getSquaresArray();
        const activeSquare = this.chessboard.getActiveSquare();
        const activePiece = activeSquare.getPiece();
        if (activePiece instanceof Pawn) {
            if (activePiece.getMoveCount() !== 0) {
                return;
            }
            const files = this.chessboard.getFiles();
            const pos = attackedSquare.getPosition();
            const file = files.indexOf(pos[0]);
            const rank = (activePiece.getColour() === "White" ? Number(pos[1]) - 1 : Number(pos[1]) + 1);
            const targetSquareIndex = this.calculateArrayIndex(file, rank);
            const oldPos = activeSquare.getPosition();
            const oldFile = files.indexOf(oldPos[0]);
            const oldRank = (activePiece.getColour() === "White" ? Number(oldPos[1]) + 1 : Number(oldPos[1]) - 1);
            const activeSquareIndex = this.calculateArrayIndex(oldFile, oldRank);
            if (squaresArray[targetSquareIndex] === squaresArray[activeSquareIndex]) {
                squaresArray[targetSquareIndex].setEnPassantSquare(true);
                this.chessboard.setEnPassantSquare(squaresArray[targetSquareIndex]);
            }
        }
    }
    enPassantCaptureDeteriminant(piece) {
        const squaresArray = this.chessboard.getSquaresArray();
        const activeSquare = this.chessboard.getActiveSquare();
        const activePiece = activeSquare.getPiece();
        const attackedSquares = this.gameData.getAttackedSquares();
        const files = this.chessboard.getFiles();
        const pos = activePiece.getPosition();
        const northEastFile = files.indexOf(pos[0]) + 1;
        const northEastRank = (activePiece.getColour() === "White" ? Number(pos[1]) + 1 : Number(pos[1]) - 1);
        const northEastSquareIndex = this.calculateArrayIndex(northEastFile, northEastRank);
        const northWestFile = files.indexOf(pos[0]) - 1;
        const northWestRank = (activePiece.getColour() === "White" ? Number(pos[1]) + 1 : Number(pos[1]) - 1);
        const northWestSquareIndex = this.calculateArrayIndex(northWestFile, northWestRank);
        if (squaresArray[northEastSquareIndex].isEnPassantSquare()) {
            attackedSquares.push(squaresArray[northEastSquareIndex]);
        }
        else if (squaresArray[northWestSquareIndex].isEnPassantSquare()) {
            attackedSquares.push(squaresArray[northWestSquareIndex]);
        }
    }
    performEnPassantCapture(attackedSquare) {
        const squaresArray = this.chessboard.getSquaresArray();
        const activeSquare = this.chessboard.getActiveSquare();
        const activePiece = activeSquare.getPiece();
        const files = this.chessboard.getFiles();
        const pos = attackedSquare.getPosition();
        const capturedPawnFile = files.indexOf(pos[0]);
        const capturedPawnRank = (activePiece.getColour() === "White" ? Number(pos[1]) - 1 : Number(pos[1]) + 1);
        const capturedPawnSquareIndex = this.calculateArrayIndex(capturedPawnFile, capturedPawnRank);
        const capturedSquare = squaresArray[capturedPawnSquareIndex];
        this.gameData.setCapturedPiece(capturedSquare.getPiece());
        capturedSquare.removePiece();
        return capturedSquare;
    }
    kingCanCastleDeterminant(player) {
        const activeSquare = this.chessboard.getActiveSquare();
        const activePiece = activeSquare.getPiece();
        if (activePiece.getColour() === "White") {
            if (activeSquare.getPosition() === "E1") {
                player.setCanCastledKingSide(false);
                player.setCanCastledQueenSide(false);
            }
        }
        else if (activePiece.getColour() === "Black") {
            if (activePiece.getPosition() === "E8") {
                player.setCanCastledKingSide(false);
                player.setCanCastledQueenSide(false);
            }
        }
    }
    rookCanCastleDeterminant(player) {
        const activeSquare = this.chessboard.getActiveSquare();
        const activePiece = activeSquare.getPiece();
        if (activePiece.getColour() === "White") {
            if (activeSquare.getPosition() === "A1") {
                player.setCanCastledQueenSide(false);
            }
            else if (activeSquare.getPosition() === "H1") {
                player.setCanCastledKingSide(false);
            }
        }
        else if (activePiece.getColour() === "Black") {
            if (activeSquare.getPosition() === "A8") {
                player.setCanCastledQueenSide(false);
            }
            else if (activeSquare.getPosition() === "H8") {
                player.setCanCastledKingSide(false);
            }
        }
    }
    westCastlingDeterminant(pos) {
        const squaresArray = this.chessboard.getSquaresArray();
        const attackedSquares = this.gameData.getAttackedSquares();
        const files = this.chessboard.getFiles();
        let file = files.indexOf(pos[0]);
        const rank = Number(pos[1]);
        const firstSquareInRow = 0;
        while (file != firstSquareInRow) {
            file = file - 1;
            const targetSquareIndex = this.calculateArrayIndex(file, rank);
            if (this.kingPassesThroughAttackedSquare(targetSquareIndex, file)) {
                return false;
            }
            if (!this.kingCanCastle(targetSquareIndex, file)) {
                return false;
            }
        }
        file = files.indexOf(pos[0]) - 2;
        const targetSquareIndex = this.calculateArrayIndex(file, rank);
        squaresArray[targetSquareIndex].setCastlingSquare(true);
        this.chessboard.setWestCastlingSquare(squaresArray[targetSquareIndex]);
        attackedSquares.push(squaresArray[targetSquareIndex]);
    }
    eastCastlingDeterminant(pos) {
        const squaresArray = this.chessboard.getSquaresArray();
        const attackedSquares = this.gameData.getAttackedSquares();
        const files = this.chessboard.getFiles();
        let file = files.indexOf(pos[0]);
        const rank = Number(pos[1]);
        const lastSquareInRow = 7;
        while (file != lastSquareInRow) {
            file = file + 1;
            const targetSquareIndex = this.calculateArrayIndex(file, rank);
            if (this.kingPassesThroughAttackedSquare(targetSquareIndex, file)) {
                return false;
            }
            if (!this.kingCanCastle(targetSquareIndex, file)) {
                return false;
            }
        }
        file = files.indexOf(pos[0]) + 2;
        const targetSquareIndex = this.calculateArrayIndex(file, rank);
        squaresArray[targetSquareIndex].setCastlingSquare(true);
        this.chessboard.setEastCastlingSquare(squaresArray[targetSquareIndex]);
        attackedSquares.push(squaresArray[targetSquareIndex]);
    }
    castleRookQueenSide(square) {
        const squaresArray = this.chessboard.getSquaresArray();
        const files = this.chessboard.getFiles();
        const pos = square.getPosition();
        const file = files.indexOf(pos[0]) - 2;
        const rank = Number(pos[1]);
        const queenSideRookSquareIndex = this.calculateArrayIndex(file, rank);
        const newRookPos = square.getPosition();
        const newRookFile = files.indexOf(newRookPos[0]) + 1;
        const newRookRank = Number(newRookPos[1]);
        const newRookPosSquareIndex = this.calculateArrayIndex(newRookFile, newRookRank);
        squaresArray[newRookPosSquareIndex].setPiece(squaresArray[queenSideRookSquareIndex].getPiece());
        squaresArray[queenSideRookSquareIndex].removePiece();
        return queenSideRookSquareIndex;
    }
    castleRookKingSide(square) {
        const squaresArray = this.chessboard.getSquaresArray();
        const files = this.chessboard.getFiles();
        const pos = square.getPosition();
        const file = files.indexOf(pos[0]) + 1;
        const rank = Number(pos[1]);
        const kingSideRookSquareIndex = this.calculateArrayIndex(file, rank);
        const newRookPos = square.getPosition();
        const newRookFile = files.indexOf(newRookPos[0]) - 1;
        const newRookRank = Number(newRookPos[1]);
        const newRookPosSquareIndex = this.calculateArrayIndex(newRookFile, newRookRank);
        squaresArray[newRookPosSquareIndex].setPiece(squaresArray[kingSideRookSquareIndex].getPiece());
        squaresArray[kingSideRookSquareIndex].removePiece();
        return kingSideRookSquareIndex;
    }
    kingPassesThroughAttackedSquare(targetSquareIndex, file) {
        const squaresArray = this.chessboard.getSquaresArray();
        if (file === 3 || file === 2 || file === 5 || file === 6) {
            const attackingPieces = squaresArray[targetSquareIndex].getAttackingPiece();
            const activePiece = this.chessboard.getActiveSquare().getPiece();
            for (let i = 0; i < attackingPieces.length; i++) {
                if (attackingPieces[i].getColour() !== activePiece.getColour()) {
                    return true;
                }
            }
        }
    }
    kingCanCastle(targetSquareIndex, file) {
        const squaresArray = this.chessboard.getSquaresArray();
        const firstSquareInRow = 0;
        const lastSquareInRow = 7;
        if ((file === firstSquareInRow || file === lastSquareInRow)) {
            return (squaresArray[targetSquareIndex].squareContainsPiece() && this.rookCanCastle(squaresArray, targetSquareIndex));
        }
        else {
            return (!this.castlingMoveIsObstructed(squaresArray, targetSquareIndex));
        }
    }
    castlingMoveIsObstructed(squaresArray, targetSquareIndex) {
        return squaresArray[targetSquareIndex].squareContainsPiece();
    }
    rookCanCastle(squaresArray, targetSquareIndex) {
        const piece = squaresArray[targetSquareIndex].getPiece();
        if (piece instanceof Rook) {
            return (piece.canCastle());
        }
    }
    calculateArrayIndex(file, rank) {
        const squaresArray = this.chessboard.getSquaresArray();
        const boardLength = squaresArray.length / 8;
        return (boardLength - rank) * boardLength + file;
    }
}

class King {
    constructor(type, colour, image) {
        this.type = type;
        this.colour = colour;
        this.image = image;
        this.initialise();
    }
    initialise() {
        this.moves = 0;
        this.inCheck = false;
        this.castled = true;
        const pieces = new Pieces();
        this.setMoveDirections(pieces.kingMoves());
        this.setGeneralDefenceDirections(pieces.generalDefence());
        this.setKnightDefenceDirections(pieces.knightDefence());
    }
    incrementMoveCount() {
        this.moves += 1;
        this.setCastledStatus(false);
    }
    isInCheck() { return this.inCheck; }
    canCastle() { return this.castled; }
    getType() { return this.type; }
    getColour() { return this.colour; }
    getImage() { return this.image; }
    getMoveDirections() { return this.moveDirections; }
    getGeneralDefenceDirections() { return this.generalDefenceDirections; }
    getKnightDefenceDirections() { return this.knightDefenceDirections; }
    getPosition() { return this.position; }
    getMoveCount() { return this.moves; }
    getStartingSquare() { return this.startingSquare; }
    setImage(image) { this.image = image; }
    setMoveDirections(directions) { this.moveDirections = directions; }
    setGeneralDefenceDirections(directions) { this.generalDefenceDirections = directions; }
    setKnightDefenceDirections(directions) { this.knightDefenceDirections = directions; }
    setPosition(pos) { this.position = pos; }
    setStartingSquare(square) { this.startingSquare = square; }
    setCheckStatus(check) { this.inCheck = check; }
    setCastledStatus(castled) { this.castled = castled; }
}

class GameLogic {
    constructor(gameData, chessboard) {
        this.gameData = gameData;
        this.chessboard = chessboard;
        this.specialMoves = new SpecialMoveHandler(this.gameData, this.chessboard);
        this.verifyingKingCheckState = false;
        this.verifyingNewMoveState = false;
        this.verifyingBoardState = false;
        this.moveContainsCheck = false;
        this.verifyingOpponentState = false;
    }
    checkRequestedMove(attackedSquare) {
        const attackedSquares = this.gameData.getAttackedSquares();
        for (let i = 0; i < attackedSquares.length; i++) {
            if (attackedSquares[i].getPosition() === attackedSquare.getPosition()) {
                return true;
            }
        }
    }
    checkSpecialMove(specialMoveSquare) {
        if (specialMoveSquare.isCastlingSquare()) {
            const westCastlingSquare = this.chessboard.getWestCastlingSquare();
            const eastCastlingSquare = this.chessboard.getEastCastlingSquare();
            switch (specialMoveSquare) {
                case this.chessboard.getWestCastlingSquare():
                    return westCastlingSquare;
                case this.chessboard.getEastCastlingSquare():
                    return eastCastlingSquare;
            }
        }
        if (specialMoveSquare.isEnPassantSquare()) {
            const enPassantSquare = this.chessboard.getEnPassantSquare();
            return enPassantSquare;
        }
    }
    checkMoveSideEffects(activeSquare, attackedSquare) {
        const player = this.getPlayerForMoveValidation();
        const activePiece = activeSquare.getPiece();
        switch (true) {
            case this.isPawn(activePiece):
                this.specialMoves.enPassantOpeningDeterminant(attackedSquare);
                break;
            case this.isRook(activePiece):
                this.specialMoves.rookCanCastleDeterminant(player);
                break;
            case this.isKing(activePiece):
                this.specialMoves.kingCanCastleDeterminant(player);
                break;
        }
    }
    squareContainsAttack(piece) {
        if (this.isVerifyingNewBoardState()) {
            this.determineMoveCase(piece);
            return;
        }
        this.determineMoveCase(piece);
        if (this.isKing(piece)) {
            this.playerCanCastleDeterminant(piece);
        }
        else if (this.isPawn(piece)) {
            this.specialMoves.enPassantCaptureDeteriminant(piece);
        }
    }
    determineMoveCase(piece) {
        const pieceMoveDirections = piece.getMoveDirections();
        if (this.isKnight(piece)) {
            this.determineKnightSpecialCases(piece, pieceMoveDirections);
            return;
        }
        this.determineGeneralMoveCases(piece, pieceMoveDirections);
    }
    determineGeneralMoveCases(piece, pieceMoveDirections) {
        const files = this.chessboard.getFiles();
        const piecePos = piece.getPosition();
        const pieceFile = files.indexOf(piecePos[0]);
        const pieceRank = Number(piecePos[1]);
        const moveDirections = {
            "N": () => (this.checkAttackableSquares(pieceFile, pieceRank + currentMove, piece)),
            'S': () => (this.checkAttackableSquares(pieceFile, pieceRank - currentMove, piece)),
            'E': () => (this.checkAttackableSquares(pieceFile + currentMove, pieceRank, piece)),
            'W': () => (this.checkAttackableSquares(pieceFile - currentMove, pieceRank, piece)),
            'NE': () => (this.checkAttackableSquares(pieceFile + currentMove, pieceRank + currentMove, piece)),
            'SE': () => (this.checkAttackableSquares(pieceFile + currentMove, pieceRank - currentMove, piece)),
            'NW': () => (this.checkAttackableSquares(pieceFile - currentMove, pieceRank + currentMove, piece)),
            'SW': () => (this.checkAttackableSquares(pieceFile - currentMove, pieceRank - currentMove, piece))
        };
        let currentMove = 0;
        pieceMoveDirections.forEach((totalMoveCount, cardinalDirection) => {
            currentMove = 1;
            while (currentMove <= totalMoveCount) {
                if (!moveDirections[cardinalDirection]()) {
                    return;
                }
                currentMove++;
            }
        });
    }
    determineKnightSpecialCases(piece, pieceMoveDirections) {
        const files = this.chessboard.getFiles();
        const piecePos = piece.getPosition();
        const pieceFile = files.indexOf(piecePos[0]);
        const pieceRank = Number(piecePos[1]);
        const moveDirections = {
            'NNE': () => (this.checkAttackableSquares(pieceFile + 1, pieceRank + 2, piece)),
            'ENE': () => (this.checkAttackableSquares(pieceFile + 2, pieceRank + 1, piece)),
            'ESE': () => (this.checkAttackableSquares(pieceFile + 2, pieceRank - 1, piece)),
            'SSE': () => (this.checkAttackableSquares(pieceFile + 1, pieceRank - 2, piece)),
            'SSW': () => (this.checkAttackableSquares(pieceFile - 1, pieceRank - 2, piece)),
            'WSW': () => (this.checkAttackableSquares(pieceFile - 2, pieceRank - 1, piece)),
            'WNW': () => (this.checkAttackableSquares(pieceFile - 2, pieceRank + 1, piece)),
            'NWN': () => (this.checkAttackableSquares(pieceFile - 1, pieceRank + 2, piece))
        };
        pieceMoveDirections.forEach((totalMoveCount, cardinalDirection) => {
            if (!moveDirections[cardinalDirection]()) {
                return;
            }
        });
    }
    checkAttackableSquares(file, rank, piece) {
        const squaresArray = this.chessboard.getSquaresArray();
        const files = this.chessboard.getFiles();
        const attackedSquareIndex = this.calculateArrayIndex(file, rank);
        const attackedSquare = squaresArray[attackedSquareIndex];
        if (attackedSquareIndex < 0 || attackedSquareIndex > squaresArray.length - 1) {
            return;
        }
        if (attackedSquare.getPosition() === (files[file] + rank)) {
            if (this.isVerifyingKingCheckState()) {
                return !this.kingCanEscapeCheck(piece, attackedSquare);
            }
            if (this.isVerifyingNewMoveState()) {
                return !this.kingBeingOpenedForAttack(piece, attackedSquare);
            }
            return this.squareContainsPiece(piece, attackedSquare);
        }
    }
    squareContainsPiece(piece, attackedSquare) {
        if (!attackedSquare.squareContainsPiece()) {
            return this.attackUnoccupiedSquares(piece, attackedSquare);
        }
        else {
            this.determinePlayerInCheck(piece, attackedSquare);
        }
        return this.attackOccupiedSquares(piece, attackedSquare);
    }
    determinePlayerInCheck(piece, attackedSquare) {
        const attackedPiece = attackedSquare.getPiece();
        if (this.isKing(attackedPiece) && this.kingInCheck(piece, attackedPiece)) {
            this.player.setCheckStatus(true);
        }
    }
    attackUnoccupiedSquares(piece, attackedSquare) {
        if (this.isPawn(piece) && !this.pawnCanAttack(attackedSquare, piece)) {
            this.setSquareAttack(attackedSquare, piece);
            return false;
        }
        else {
            if (!this.isPawn(piece)) {
                this.setSquareAttack(attackedSquare, piece);
            }
        }
        if (this.isKing(piece)) {
            const attackingPieces = attackedSquare.getAttackingPiece();
            for (let i = 0; i < attackingPieces.length; i++) {
                if (attackingPieces[i].getColour() !== piece.getColour()) {
                    return;
                }
            }
        }
        if (!this.isVerifyingNewBoardState()) {
            this.checkKingDefences(attackedSquare);
            if (!this.newMoveContainsCheck()) {
                this.gameData.setAttackedSquare(attackedSquare);
                return true;
            }
        }
        else {
            if (!this.isVerifyingOpponentState() && piece.getColour() === this.player.getColour()) {
                this.checkKingDefences(attackedSquare);
                if (!this.newMoveContainsCheck()) {
                    this.gameData.incrementValidMoveCount();
                }
            }
        }
        return true;
    }
    attackOccupiedSquares(piece, attackedSquare) {
        if (piece.getColour() === attackedSquare.getPiece().getColour()) {
            this.setSquareAttack(attackedSquare, piece);
            return false;
        }
        if (this.isPawn(piece)) {
            if (this.pawnCanAttack(attackedSquare, piece)) {
                return false;
            }
            else {
                this.setSquareAttack(attackedSquare, piece);
            }
        }
        else {
            this.setSquareAttack(attackedSquare, piece);
        }
        if (this.isKing(attackedSquare.getPiece())) {
            return false;
        }
        if (this.isKing(piece)) {
            const attackingPieces = attackedSquare.getAttackingPiece();
            for (let i = 0; i < attackingPieces.length; i++) {
                if (attackingPieces[i].getColour() !== piece.getColour()) {
                    return;
                }
            }
        }
        if (!this.isVerifyingNewBoardState()) {
            this.checkKingDefences(attackedSquare);
            if (!this.newMoveContainsCheck()) {
                this.gameData.setAttackedSquare(attackedSquare);
                return false;
            }
        }
        else {
            if (!this.isVerifyingOpponentState() && piece.getColour() === this.player.getColour()) {
                this.checkKingDefences(attackedSquare);
                if (!this.newMoveContainsCheck()) {
                    this.gameData.incrementValidMoveCount();
                }
            }
        }
        return false;
    }
    setSquareAttack(attackedSquare, piece) {
        attackedSquare.setSquareAttacked(true);
        attackedSquare.setAttackingPiece(piece);
    }
    checkKingDefences(attackedSquare) {
        this.setVerifyingNewMoveState(true);
        this.setNewMoveContainsCheck(false);
        const activeSquare = this.chessboard.getActiveSquare();
        const activePiece = activeSquare.getPiece();
        const defendingPiece = attackedSquare.getPiece();
        const kingPiece = this.player.getKing();
        activeSquare.removePiece();
        this.chessboard.setActiveSquare(attackedSquare);
        attackedSquare.setPiece(activePiece);
        this.moveContainsCheckDeterminant(kingPiece);
        attackedSquare.removePiece();
        activeSquare.setPiece(activePiece);
        if (defendingPiece) {
            attackedSquare.setPiece(defendingPiece);
        }
        this.chessboard.setActiveSquare(activeSquare);
        this.setVerifyingNewMoveState(false);
    }
    moveContainsCheckDeterminant(piece) {
        const king = piece;
        const generalDefence = king.getGeneralDefenceDirections();
        const knightDefence = king.getKnightDefenceDirections();
        this.setVerifyingKingCheckState(true);
        this.determineGeneralMoveCases(king, generalDefence);
        this.determineKnightSpecialCases(king, knightDefence);
        this.setVerifyingKingCheckState(false);
    }
    kingBeingOpenedForAttack(kingPiece, attackedSquare) {
        const files = this.chessboard.getFiles();
        const attackingPiece = attackedSquare.getPiece();
        if (attackingPiece) {
            const kingFile = files.indexOf(kingPiece.getPosition()[0]);
            const kingRank = Number(kingPiece.getPosition()[1]);
            const attackingPieceFile = files.indexOf(attackingPiece.getPosition()[0]);
            const attackingPieceRank = Number(attackingPiece.getPosition()[1]);
            if (attackingPiece.getColour() === this.player.getColour()) {
                return;
            }
            if (this.isRook(attackingPiece)) {
                return this.rookIsAttackingKing(kingPiece, attackedSquare);
            }
            else if (this.isQueen(attackingPiece)) {
                return this.queenIsAttackingKing(kingPiece, attackedSquare);
            }
            else {
                if (kingFile !== attackingPieceFile && kingRank !== attackingPieceRank) {
                    return this.determineDiagonalAttackingPiece(kingPiece, attackedSquare);
                }
            }
        }
    }
    determineDiagonalAttackingPiece(kingPiece, attackedSquare) {
        const attackingPiece = attackedSquare.getPiece();
        switch (true) {
            case this.isPawn(attackingPiece):
                return this.pawnIsAttackingKing(kingPiece, attackedSquare);
            case this.isBishop(attackingPiece):
                return this.bishopIsAttackingKing(kingPiece, attackedSquare);
            case this.isKnight(attackingPiece):
                return this.knightIsAttackingKing(kingPiece, attackedSquare);
        }
    }
    rookIsAttackingKing(kingPiece, attackedSquare) {
        const files = this.chessboard.getFiles();
        const attackingPiece = attackedSquare.getPiece();
        const kingFile = files.indexOf(kingPiece.getPosition()[0]);
        const kingRank = Number(kingPiece.getPosition()[1]);
        const attackingPieceFile = files.indexOf(attackingPiece.getPosition()[0]);
        const attackingPieceRank = Number(attackingPiece.getPosition()[1]);
        if ((kingFile === attackingPieceFile)) {
            this.setNewMoveContainsCheck(true);
            return true;
        }
        else if (kingRank === attackingPieceRank) {
            this.setNewMoveContainsCheck(true);
            return true;
        }
    }
    queenIsAttackingKing(kingPiece, attackedSquare) {
        const files = this.chessboard.getFiles();
        const attackingPiece = attackedSquare.getPiece();
        const kingFile = files.indexOf(kingPiece.getPosition()[0]);
        const kingRank = Number(kingPiece.getPosition()[1]);
        const attackingPieceFile = files.indexOf(attackingPiece.getPosition()[0]);
        const attackingPieceRank = Number(attackingPiece.getPosition()[1]);
        if (this.squaresLineUp(kingFile, kingRank, attackingPieceFile, attackingPieceRank)) {
            this.setNewMoveContainsCheck(true);
            return true;
        }
    }
    bishopIsAttackingKing(kingPiece, attackedSquare) {
        const files = this.chessboard.getFiles();
        const attackingPiece = attackedSquare.getPiece();
        const kingFile = files.indexOf(kingPiece.getPosition()[0]);
        const kingRank = Number(kingPiece.getPosition()[1]);
        const attackingPieceFile = files.indexOf(attackingPiece.getPosition()[0]);
        const attackingPieceRank = Number(attackingPiece.getPosition()[1]);
        if (this.squaresLineUp(kingFile, kingRank, attackingPieceFile, attackingPieceRank)) {
            this.setNewMoveContainsCheck(true);
            return true;
        }
    }
    knightIsAttackingKing(kingPiece, attackedSquare) {
        const files = this.chessboard.getFiles();
        const attackingPiece = attackedSquare.getPiece();
        const kingFile = files.indexOf(kingPiece.getPosition()[0]);
        const kingRank = Number(kingPiece.getPosition()[1]);
        const attackingPieceFile = files.indexOf(attackingPiece.getPosition()[0]);
        const attackingPieceRank = Number(attackingPiece.getPosition()[1]);
        if (!this.squaresLineUp(kingFile, kingRank, attackingPieceFile, attackingPieceRank)) {
            this.setNewMoveContainsCheck(true);
            return true;
        }
    }
    pawnIsAttackingKing(kingPiece, attackedSquare) {
        const files = this.chessboard.getFiles();
        const attackingPiece = attackedSquare.getPiece();
        const kingFile = files.indexOf(kingPiece.getPosition()[0]);
        const kingRank = Number(kingPiece.getPosition()[1]);
        const attackingPieceFile = files.indexOf(attackingPiece.getPosition()[0]);
        const attackingPieceRank = Number(attackingPiece.getPosition()[1]);
        if (this.player.getColour() === "White") {
            if (attackingPieceFile - 1 === kingFile && attackingPieceRank - 1 === kingRank) {
                this.setNewMoveContainsCheck(true);
            }
            else if (attackingPieceFile + 1 === kingFile && attackingPieceRank - 1 === kingRank) {
                this.setNewMoveContainsCheck(true);
            }
        }
        else if (this.player.getColour() === "Black") {
            if (attackingPieceFile - 1 === kingFile && attackingPieceRank + 1 === kingRank) {
                this.setNewMoveContainsCheck(true);
            }
            else if (attackingPieceFile + 1 === kingFile && attackingPieceRank + 1 === kingRank) {
                this.setNewMoveContainsCheck(true);
            }
        }
    }
    kingCanEscapeCheck(kingPiece, attackedSquare) {
        const attackingPiece = attackedSquare.getPiece();
        if (attackingPiece) {
            return !this.kingBeingOpenedForAttack(kingPiece, attackedSquare);
        }
        return false;
    }
    kingInCheck(piece, attackedPiece) {
        if (this.isPawn(piece) && piece.getPosition()[0] === attackedPiece.getPosition()[0]) {
            return;
        }
        return (piece.getColour() !== attackedPiece.getColour() && this.player.getColour() === attackedPiece.getColour());
    }
    determineAttackedSquares() {
        const squaresArray = this.chessboard.getSquaresArray();
        this.gameData.resetValidMoveCount();
        this.setVerifyingNewBoardState(true);
        for (let i = 0; i < squaresArray.length; i++) {
            squaresArray[i].setSquareAttacked(false);
            squaresArray[i].clearAttackingPieces();
        }
        this.setVerifyingOpponentState(true);
        for (let i = 0; i < squaresArray.length; i++) {
            if (squaresArray[i].squareContainsPiece() && squaresArray[i].getPiece().getColour() !== this.player.getColour()) {
                this.chessboard.setActiveSquare(squaresArray[i]);
                this.squareContainsAttack(squaresArray[i].getPiece());
            }
        }
        this.setVerifyingOpponentState(false);
        for (let i = 0; i < squaresArray.length; i++) {
            if (squaresArray[i].squareContainsPiece() && squaresArray[i].getPiece().getColour() === this.player.getColour()) {
                this.chessboard.setActiveSquare(squaresArray[i]);
                this.squareContainsAttack(squaresArray[i].getPiece());
            }
        }
        this.setVerifyingNewBoardState(false);
    }
    playerCanCastleDeterminant(piece) {
        if (piece instanceof King) {
            if (!this.player.canCastleKingSide() && !this.player.canCastleQueenSide()) {
                return;
            }
            if (!piece.canCastle() || piece.isInCheck()) {
                return;
            }
            if (piece.getStartingSquare().getPosition() !== piece.getPosition()) {
                return;
            }
            this.specialMoves.westCastlingDeterminant(piece.getPosition());
            this.specialMoves.eastCastlingDeterminant(piece.getPosition());
        }
    }
    performEnPassantCapture(captureSquare) {
        return this.specialMoves.performEnPassantCapture(captureSquare);
    }
    determineEnPassantSquare(squarePosition) {
        return this.specialMoves.determineEnPassantSquare(squarePosition);
    }
    castleRookQueenSide(queenSideSquare) {
        return this.specialMoves.castleRookQueenSide(queenSideSquare);
    }
    castleRookKingSide(kingSideSquare) {
        return this.specialMoves.castleRookKingSide(kingSideSquare);
    }
    calculateArrayIndex(file, rank) {
        const squaresArray = this.chessboard.getSquaresArray();
        const boardLength = squaresArray.length / 8;
        return (boardLength - rank) * boardLength + file;
    }
    squaresLineUp(firstSquareFile, firstSquareRank, secondSquareFile, secondSquareRank) {
        const squaresLineUp = Math.abs((firstSquareFile - secondSquareFile) & (firstSquareRank - secondSquareRank)) ===
            Math.abs((secondSquareFile - firstSquareFile) & (secondSquareRank - firstSquareRank));
        return squaresLineUp;
    }
    isPawn(piece) { return piece.getType() === 'P' || piece.getType() === 'p'; }
    isBishop(piece) { return piece.getType() === 'B' || piece.getType() === 'b'; }
    isKnight(piece) { return piece.getType() === 'N' || piece.getType() === 'n'; }
    isRook(piece) { return piece.getType() === 'R' || piece.getType() === 'r'; }
    isQueen(piece) { return piece.getType() === 'Q' || piece.getType() === 'q'; }
    isKing(piece) { return piece.getType() === 'K' || piece.getType() === 'k'; }
    isVerifyingKingCheckState() { return this.verifyingKingCheckState; }
    isVerifyingNewMoveState() { return this.verifyingNewMoveState; }
    isVerifyingNewBoardState() { return this.verifyingBoardState; }
    isVerifyingOpponentState() { return this.verifyingOpponentState; }
    newMoveContainsCheck() { return this.moveContainsCheck; }
    pawnCanAttack(square, piece) { return square.getPosition()[0] === piece.getPosition()[0]; }
    getPlayerForMoveValidation() { return this.player; }
    setPlayerForMoveValidation(player) { this.player = player; }
    setVerifyingKingCheckState(verifying) { this.verifyingKingCheckState = verifying; }
    setVerifyingNewMoveState(verifying) { this.verifyingNewMoveState = verifying; }
    setVerifyingNewBoardState(verifying) { this.verifyingBoardState = verifying; }
    setVerifyingOpponentState(verifying) { this.verifyingOpponentState = verifying; }
    setNewMoveContainsCheck(check) { this.moveContainsCheck = check; }
}

class FenParser {
    constructor(chessboard) {
        this.chessboard = chessboard;
    }
    parseFenString(fen) {
        const fenString = fen.split(" ");
        const positions = fenString[0].split("/");
        const pieces = this.chessboard.getPiecePositionsArray();
        let currentSquare = 0;
        positions.forEach(rank => {
            rank.split("").forEach(char => {
                if (!Number(char)) {
                    pieces[currentSquare] = char;
                    currentSquare++;
                }
                else {
                    currentSquare += Number(char);
                }
            });
        });
        return pieces;
    }
}

class FenBuilder {
    constructor(gameState, chessboard, player) {
        this.gameState = gameState;
        this.chessboard = chessboard;
        this.player = player;
    }
    createFenPositions() {
        const board = this.chessboard.getSquaresArray();
        let newFenString = "";
        let emptySquares = 0;
        for (let i = 0; i < board.length; i++) {
            if (i % 8 === 0 && i !== 0) {
                newFenString += "/";
                emptySquares = 0;
            }
            if (board[i].squareContainsPiece()) {
                newFenString += board[i].getPiece().getType();
                emptySquares = 0;
            }
            else {
                emptySquares++;
                if ((i + 1) < board.length) {
                    if ((i + 1) % 8 === 0) {
                        newFenString += emptySquares;
                    }
                    else if (board[i + 1].squareContainsPiece()) {
                        newFenString += emptySquares;
                    }
                }
            }
        }
        return newFenString;
    }
    createFenCurrentTurn() {
        const currentTurn = this.gameState.getCurrentTurn();
        const fenCurrentTurn = (currentTurn[0] === "W" ? " w " : " b ");
        return fenCurrentTurn;
    }
    createFenCastlingStatus() {
        let fenCastlingState = "";
        if (this.player.getColour() === "White") {
            if (this.player.canCastleKingSide()) {
                fenCastlingState += "K";
            }
            if (this.player.canCastleQueenSide()) {
                fenCastlingState += "Q";
            }
            fenCastlingState += this.appendFenCastlingBlackStatus();
        }
        else if (this.player.getColour() === "Black") {
            fenCastlingState = this.appendFenCastlingWhiteStatus();
            if (this.player.canCastleKingSide()) {
                fenCastlingState += "k";
            }
            if (this.player.canCastleQueenSide()) {
                fenCastlingState += "q";
            }
        }
        if (fenCastlingState.length === 0) {
            return "-";
        }
        this.gameState.setFenCastlingState(fenCastlingState);
        return fenCastlingState;
    }
    appendFenCastlingWhiteStatus() {
        let fenWhiteCastlingState = "";
        this.gameState.getFenCastlingState().split("").forEach(char => {
            switch (char) {
                case "K":
                    fenWhiteCastlingState += char;
                    break;
                case "Q":
                    fenWhiteCastlingState += char;
                    break;
            }
        });
        return fenWhiteCastlingState;
    }
    appendFenCastlingBlackStatus() {
        let fenBlackCastlingState = "";
        this.gameState.getFenCastlingState().split("").forEach(char => {
            switch (char) {
                case "k":
                    fenBlackCastlingState += char;
                    break;
                case "q":
                    fenBlackCastlingState += char;
                    break;
            }
        });
        return fenBlackCastlingState;
    }
    createFenEnPassantSquare() {
        const enPassantSquare = this.chessboard.getEnPassantSquare();
        const fenEnPassantSquare = (enPassantSquare ? " " + enPassantSquare.getPosition() + " " : " - ");
        return fenEnPassantSquare;
    }
    createFenHalfmoveClock() { return this.gameState.getHalfmoveClock() + " "; }
    createFenFullmoveClock() { return this.gameState.getFullmoveClock(); }
}

class Knight {
    constructor(type, colour, image) {
        this.type = type;
        this.colour = colour;
        this.image = image;
        this.initialise();
    }
    initialise() {
        this.moves = 0;
        const pieces = new Pieces();
        this.setMoveDirections(pieces.knightMoves());
    }
    incrementMoveCount() { this.moves += 1; }
    getType() { return this.type; }
    getColour() { return this.colour; }
    getImage() { return this.image; }
    getMoveDirections() { return this.moveDirections; }
    getPosition() { return this.position; }
    getMoveCount() { return this.moves; }
    getStartingSquare() { return this.startingSquare; }
    setImage(image) { this.image = image; }
    setMoveDirections(directions) { this.moveDirections = directions; }
    setPosition(pos) { this.position = pos; }
    setStartingSquare(square) { this.startingSquare = square; }
}

class Bishop {
    constructor(type, colour, image) {
        this.type = type;
        this.colour = colour;
        this.image = image;
        this.initialise();
    }
    initialise() {
        this.moves = 0;
        const pieces = new Pieces();
        this.setMoveDirections(pieces.bishopMoves());
    }
    incrementMoveCount() { this.moves += 1; }
    getType() { return this.type; }
    getColour() { return this.colour; }
    getImage() { return this.image; }
    getMoveDirections() { return this.moveDirections; }
    getPosition() { return this.position; }
    getMoveCount() { return this.moves; }
    getStartingSquare() { return this.startingSquare; }
    setImage(image) { this.image = image; }
    setMoveDirections(directions) { this.moveDirections = directions; }
    setPosition(pos) { this.position = pos; }
    setStartingSquare(square) { this.startingSquare = square; }
}

class Queen {
    constructor(type, colour, image) {
        this.type = type;
        this.colour = colour;
        this.image = image;
        this.initialise();
    }
    initialise() {
        this.moves = 0;
        const pieces = new Pieces();
        this.setMoveDirections(pieces.queenMoves());
    }
    incrementMoveCount() { this.moves += 1; }
    getType() { return this.type; }
    getColour() { return this.colour; }
    getImage() { return this.image; }
    getMoveDirections() { return this.moveDirections; }
    getMoveCount() { return this.moves; }
    getPosition() { return this.position; }
    getStartingSquare() { return this.startingSquare; }
    setImage(image) { this.image = image; }
    setMoveDirections(directions) { this.moveDirections = directions; }
    setPosition(pos) { this.position = pos; }
    setStartingSquare(square) { this.startingSquare = square; }
}

class PiecesFactory extends Pieces {
    typeOfPiece(piece) {
        const white = "White";
        const black = "Black";
        switch (piece) {
            case 'P':
                const whitePawn = this.getChessPieceImgs().get(piece);
                if (whitePawn) {
                    return new Pawn(piece, white, whitePawn);
                }
                else {
                    throw new Error("Image not defined");
                }
            case 'N':
                const whiteKnight = this.getChessPieceImgs().get(piece);
                if (whiteKnight) {
                    return new Knight(piece, white, whiteKnight);
                }
                else {
                    throw new Error("Image not defined");
                }
            case 'B':
                const whiteBishop = this.getChessPieceImgs().get(piece);
                if (whiteBishop) {
                    return new Bishop(piece, white, whiteBishop);
                }
                else {
                    throw new Error("Image not defined");
                }
            case 'R':
                const whiteRook = this.getChessPieceImgs().get(piece);
                if (whiteRook) {
                    return new Rook(piece, white, whiteRook);
                }
                else {
                    throw new Error("Image not defined");
                }
            case 'Q':
                const whiteQueen = this.getChessPieceImgs().get(piece);
                if (whiteQueen) {
                    return new Queen(piece, white, whiteQueen);
                }
                else {
                    throw new Error("Image not defined");
                }
            case 'K':
                const whiteKing = this.getChessPieceImgs().get(piece);
                if (whiteKing) {
                    return new King(piece, white, whiteKing);
                }
                else {
                    throw new Error("Image not defined");
                }
            case 'p':
                const blackPawn = this.getChessPieceImgs().get(piece);
                if (blackPawn) {
                    return new Pawn(piece, black, blackPawn);
                }
                else {
                    throw new Error("Image not defined");
                }
            case 'n':
                const blackKnight = this.getChessPieceImgs().get(piece);
                if (blackKnight) {
                    return new Knight(piece, black, blackKnight);
                }
                else {
                    throw new Error("Image not defined");
                }
            case 'b':
                const blackBishop = this.getChessPieceImgs().get(piece);
                if (blackBishop) {
                    return new Bishop(piece, black, blackBishop);
                }
                else {
                    throw new Error("Image not defined");
                }
            case 'r':
                const blackRook = this.getChessPieceImgs().get(piece);
                if (blackRook) {
                    return new Rook(piece, black, blackRook);
                }
                else {
                    throw new Error("Image not defined");
                }
            case 'q':
                const blackQueen = this.getChessPieceImgs().get(piece);
                if (blackQueen) {
                    return new Queen(piece, black, blackQueen);
                }
                else {
                    throw new Error("Image not defined");
                }
            case 'k':
                const blackKing = this.getChessPieceImgs().get(piece);
                if (blackKing) {
                    return new King(piece, black, blackKing);
                }
                else {
                    throw new Error("Image not defined");
                }
            default:
                throw new Error("Piece does not exist");
        }
    }
}

const files = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
const ranks = [8, 7, 6, 5, 4, 3, 2, 1];
const pieces = "PPPPPPppppppNNnnBBbbRRrrQqKk";
class Board {
    constructor() {
        this.initialise();
    }
    initialise() {
        this.squares = [];
        this.piecePositionsArray = [];
        this.piecesArray = [];
    }
    clearSpecialSquares() {
        if (this.getEastCastlingSquare()) {
            this.eastCastlingSquare.setCastlingSquare(false);
            delete this.westCastlingSquare;
        }
        if (this.getWestCastlingSquare()) {
            this.westCastlingSquare.setCastlingSquare(false);
            delete this.eastCastlingSquare;
        }
        if (this.getEnPassantSquare()) {
            this.enPassantSquare.setEnPassantSquare(false);
            delete this.enPassantSquare;
        }
    }
    getFiles() { return files; }
    getRanks() { return ranks; }
    getStartingPieces() { return pieces; }
    getSquaresArray() { return this.squares; }
    getPiecePositionsArray() { return this.piecePositionsArray; }
    getPieceObjectArray() { return this.piecesArray; }
    getActiveSquare() { return this.activeSquare; }
    getWestCastlingSquare() { return this.westCastlingSquare; }
    getEastCastlingSquare() { return this.eastCastlingSquare; }
    getEnPassantSquare() { return this.enPassantSquare; }
    setSquaresArray(squares) { this.squares = squares; }
    setPiecePositionsArray(pieces) { this.piecePositionsArray = pieces; }
    setPieceObjectArray(piece) { this.piecesArray.push(piece); }
    setActiveSquare(square) { this.activeSquare = square; }
    setWestCastlingSquare(square) { this.westCastlingSquare = square; }
    setEastCastlingSquare(square) { this.eastCastlingSquare = square; }
    setEnPassantSquare(square) { this.enPassantSquare = square; }
}

class Square {
    constructor(pos, x, y, w, h) {
        this.pos = pos;
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.attackingPieces = [];
        this.castlingSquare = false;
        this.enPassantSquare = false;
    }
    removePiece() {
        delete this.piece;
        this.hasPiece = false;
        this.isAttacked = false;
    }
    squareContainsPiece() { return this.hasPiece; }
    squareIsAttacked() { return this.isAttacked; }
    isCastlingSquare() { return this.castlingSquare; }
    isEnPassantSquare() { return this.enPassantSquare; }
    clearAttackingPieces() { this.attackingPieces = []; }
    getAttackingPiece() { return this.attackingPieces; }
    getPiece() { return this.piece; }
    getPosition() { return this.pos; }
    getX() { return this.x; }
    getY() { return this.y; }
    getWidth() { return this.w; }
    getHeight() { return this.h; }
    getColour() { return this.colour; }
    setX(x) { this.x = x; }
    setY(y) { this.y = y; }
    setWidth(width) { this.w = width; }
    setHeight(height) { this.h = height; }
    setPiece(piece) {
        this.piece = piece;
        this.hasPiece = true;
        piece.setPosition(this.pos);
    }
    setSquareAttacked(attacked) { this.isAttacked = attacked; }
    setAttackingPiece(piece) { this.attackingPieces.push(piece); }
    setColour(colour) { this.colour = colour; }
    setCastlingSquare(isCastlingSquare) { this.castlingSquare = isCastlingSquare; }
    setEnPassantSquare(isEnPassantSquare) { this.enPassantSquare = isEnPassantSquare; }
}

class Player {
    constructor(colour) {
        this.colour = colour;
        this.inCheck = false;
        this.turnComplete = false;
        this.castleQueenSide = false;
        this.castleKingSide = false;
    }
    isInCheck() { return this.inCheck; }
    isDemonstrationMode() { return this.isDemo; }
    hasCompletedTurn() { return this.turnComplete; }
    canCastleQueenSide() { return this.castleQueenSide; }
    canCastleKingSide() { return this.castleKingSide; }
    getColour() { return this.colour; }
    getKing() { return this.king; }
    setDemonstrationMode() { this.isDemo = true; }
    setColour(colour) { this.colour = colour; }
    setCheckStatus(check) { this.inCheck = check; }
    setTurnComplete(completed) { this.turnComplete = completed; }
    setCanCastledQueenSide(canCastle) { this.castleQueenSide = canCastle; }
    setCanCastledKingSide(canCastle) { this.castleKingSide = canCastle; }
    setKing(king) { this.king = king; }
}

class Game {
    constructor(player, fen, turn) {
        this.setPlayer(player, turn);
        this.gameData = new GameData;
        this.gameState = new GameState();
        this.chessboard = new Board();
        this.gameLogic = new GameLogic(this.gameData, this.chessboard);
        this.isSquareClicked = false;
        this.specialMoveInitiated = false;
        this.pawnBeingMoved = false;
        this.pieceBeingCaptured = false;
        this.gameOver = false;
        this.setGameState(fen, turn);
    }
    setGameState(fen, turn) {
        const defaultState = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
        const fenString = fen.split(" ").length === 6 ? fen : defaultState;
        this.gameState.setFenString(fenString);
        this.gameState.setCurrentTurn(turn);
        this.setPlayerCastlingState(fenString);
        this.gameState.setHalfmoveClock(Number(fen.split(" ")[4]));
        this.gameState.setFullmoveClock(Number(fen.split(" ")[5]));
    }
    setPlayer(player, turn) {
        if (player === "Demo") {
            this.player = new Player(turn);
            this.player.setDemonstrationMode();
            return;
        }
        player === "Player 1" ? this.player = new Player("White") : this.player = new Player("Black");
    }
    switchPlayerForDemonstrationMode() {
        this.player.getColour() === "White" ? this.player.setColour("Black") : this.player.setColour("White");
        this.player.setDemonstrationMode();
        this.player.setCheckStatus(false);
        this.setKingForDemonstrationMode();
        this.setCastlingStatusforDemoMode();
    }
    setCastlingStatusforDemoMode() {
        this.player.setCanCastledKingSide(false);
        this.player.setCanCastledQueenSide(false);
        this.setPlayerCastlingState(this.gameState.getFenString());
    }
    setKingForDemonstrationMode() {
        const squaresArray = this.chessboard.getSquaresArray();
        for (let i = 0; i < squaresArray.length; i++) {
            const piece = squaresArray[i].getPiece();
            if (piece && (piece instanceof King && piece.getColour() === this.player.getColour())) {
                this.player.setKing(squaresArray[i].getPiece());
            }
        }
    }
    initialise(cw, ch) {
        const files = this.chessboard.getFiles();
        const ranks = this.chessboard.getRanks();
        let squaresArray = this.chessboard.getSquaresArray();
        for (let i = 0; i < files.length; i++) {
            for (let j = 0; j < ranks.length; j++) {
                squaresArray[i + j * 8] = new Square(files[i] + ranks[j], i * cw, j * cw, cw, ch);
            }
        }
        this.chessboard.setSquaresArray(squaresArray);
        this.setPiecePositions();
        this.gameLogic.setPlayerForMoveValidation(this.player);
        this.gameLogic.determineAttackedSquares();
    }
    updateGameState(gameProps) {
        const squaresArray = this.chessboard.getSquaresArray();
        if (gameProps.nextPlayerTurn !== this.gameState.getCurrentTurn()) {
            for (let i = 0; i < squaresArray.length; i++) {
                if (squaresArray[i].getPosition() === gameProps.movePieceFrom) {
                    this.chessboard.setActiveSquare(squaresArray[i]);
                }
            }
            for (let i = 0; i < squaresArray.length; i++) {
                if (squaresArray[i].getPosition() === gameProps.movePieceTo) {
                    this.gameState.setCurrentTurn(gameProps.nextPlayerTurn);
                    this.gameState.setFenString(gameProps.nextFenString);
                    this.gameState.setHalfmoveClock(Number(gameProps.nextFenString.split(" ")[4]));
                    this.gameState.setFullmoveClock(Number(gameProps.nextFenString.split(" ")[5]));
                    return squaresArray[i];
                }
            }
        }
    }
    updateSquareSizeProps(cw, ch) {
        const files = this.chessboard.getFiles();
        const ranks = this.chessboard.getRanks();
        let squaresArray = this.chessboard.getSquaresArray();
        for (let i = 0; i < files.length; i++) {
            for (let j = 0; j < ranks.length; j++) {
                squaresArray[i + j * 8].setX(i * cw);
                squaresArray[i + j * 8].setY(j * cw);
                squaresArray[i + j * 8].setWidth(cw);
                squaresArray[i + j * 8].setHeight(ch);
            }
        }
        this.chessboard.setSquaresArray(squaresArray);
    }
    setPiecePositions() {
        const fenParser = new FenParser(this.chessboard);
        const piecesFactory = new PiecesFactory();
        const startingFen = this.gameState.getFenString();
        const squaresArray = this.chessboard.getSquaresArray();
        const piecesArray = fenParser.parseFenString(startingFen);
        piecesArray.forEach((pieceRequired, index) => {
            startingFen.split("").forEach((pieceToPlace) => {
                if (pieceRequired === pieceToPlace) {
                    const newPiece = (piecesFactory.typeOfPiece(pieceToPlace));
                    newPiece.setStartingSquare(squaresArray[index]);
                    squaresArray[index].setPiece(newPiece);
                    if (newPiece instanceof King && newPiece.getColour() === this.player.getColour()) {
                        this.player.setKing(newPiece);
                    }
                }
            });
        });
    }
    createFenString() {
        const fenBuilder = new FenBuilder(this.gameState, this.chessboard, this.player);
        const positions = fenBuilder.createFenPositions();
        const currentTurn = fenBuilder.createFenCurrentTurn();
        const castling = fenBuilder.createFenCastlingStatus();
        const enPassant = fenBuilder.createFenEnPassantSquare();
        const halfmoveClock = fenBuilder.createFenHalfmoveClock();
        const fullmoveClock = fenBuilder.createFenFullmoveClock();
        const newFenString = positions + currentTurn + castling + enPassant + halfmoveClock + fullmoveClock;
        return newFenString;
    }
    setPlayerCastlingState(fen) {
        const fenCastling = fen.split(" ")[2];
        if (fenCastling.length === 0) {
            return "-";
        }
        let newFenCastlingState = "";
        fenCastling.split("").forEach((char) => {
            switch (char) {
                case "K":
                    this.setPlayerCanCastleKingSide(char);
                    newFenCastlingState += char;
                    break;
                case "Q":
                    this.setPlayerCanCastleQueenSide(char);
                    newFenCastlingState += char;
                    break;
                case "k":
                    this.setPlayerCanCastleKingSide(char);
                    newFenCastlingState += char;
                    break;
                case "q":
                    this.setPlayerCanCastleQueenSide(char);
                    newFenCastlingState += char;
                    break;
            }
        });
        this.gameState.setFenCastlingState(newFenCastlingState);
    }
    setPlayerCanCastleKingSide(kingSide) {
        if (this.player.getColour() === "White" && kingSide === "K") {
            this.player.setCanCastledKingSide(true);
        }
        else if (this.player.getColour() === "Black" && kingSide === "k") {
            this.player.setCanCastledKingSide(true);
        }
    }
    setPlayerCanCastleQueenSide(kingSide) {
        if (this.player.getColour() === "White" && kingSide === "Q") {
            this.player.setCanCastledQueenSide(true);
        }
        else if (this.player.getColour() === "Black" && kingSide === "q") {
            this.player.setCanCastledQueenSide(true);
        }
    }
    handleActivatedSquare(activeSquare) {
        this.setSquareActive(true);
        this.chessboard.setActiveSquare(activeSquare);
    }
    handleDeactivatedSquare() {
        const emptySquare = new Square('0', 0, 0, 0, 0);
        this.chessboard.setActiveSquare(emptySquare);
        this.setSquareActive(false);
    }
    handleOverwriteSquare(activeSquare, activePiece) {
        if (activeSquare.getPiece()) {
            this.gameData.setCapturedPiece(activeSquare.getPiece());
        }
        this.chessboard.getActiveSquare().removePiece();
        this.chessboard.setActiveSquare(activeSquare);
        activeSquare.setPiece(activePiece);
    }
    preMoveProcessing(attackedSquare) {
        const activeSquare = this.chessboard.getActiveSquare();
        const activePiece = activeSquare.getPiece();
        this.chessboard.clearSpecialSquares();
        this.gameLogic.checkMoveSideEffects(activeSquare, attackedSquare);
        this.incrementMoveCount(activePiece);
        this.fiftyMoveRuleDeterminant(attackedSquare, activePiece);
        this.fiftyMoveRuleProcessing();
        this.fullMoveClockProcessing();
    }
    postMoveProcessing() {
        if (this.gameState.getHalfmoveClock() === 50) {
            this.setGameOver(true);
        }
    }
    fiftyMoveRuleDeterminant(attackedSquare, activePiece) {
        if (attackedSquare.squareContainsPiece()) {
            this.setPieceIsBeingCaptured(true);
        }
        else if (activePiece instanceof Pawn) {
            this.setPawnIsBeingMoved(true);
        }
    }
    fiftyMoveRuleProcessing() {
        if (!this.pawnIsBeingMoved() && !this.pieceIsBeingCaptured()) {
            const halfmoveClock = this.gameState.getHalfmoveClock();
            this.gameState.setHalfmoveClock(halfmoveClock + 1);
            return;
        }
        this.gameState.setHalfmoveClock(0);
        this.setPawnIsBeingMoved(false);
        this.setPieceIsBeingCaptured(false);
    }
    fullMoveClockProcessing() {
        if (this.player.getColour() === "White" && this.gameState.getFullmoveClock() === 1) {
            return;
        }
        const fullmoveClock = this.gameState.getFullmoveClock();
        this.gameState.setFullmoveClock(fullmoveClock + 1);
    }
    determinePlayerSpecialMoveCase(square) {
        const activePiece = this.chessboard.getActiveSquare().getPiece();
        if (activePiece instanceof King) {
            if (square === this.chessboard.getWestCastlingSquare()) {
                this.initiateCastling();
                return;
            }
            if (square === this.chessboard.getEastCastlingSquare()) {
                this.initiateCastling();
                return;
            }
        }
        if (activePiece instanceof Pawn) {
            if (square === this.chessboard.getEnPassantSquare()) {
                this.initiateEnPassantCapture();
                return;
            }
        }
        this.setSpecialMoveInProgress(false);
    }
    initiateCastling() {
        this.player.setCanCastledKingSide(false);
        this.player.setCanCastledQueenSide(false);
        this.setSpecialMoveInProgress(true);
    }
    initiateEnPassantCapture() {
        this.setSpecialMoveInProgress(true);
    }
    checkValidMoves(pos, activePiece) {
        this.gameLogic.setPlayerForMoveValidation(this.player);
        this.gameLogic.squareContainsAttack(activePiece);
    }
    checkSpecialMoves(square) {
        const specialMoveSquare = this.gameLogic.checkSpecialMove(square);
        if (specialMoveSquare) {
            if (specialMoveSquare.isCastlingSquare()) {
                if (specialMoveSquare === this.chessboard.getWestCastlingSquare()) {
                    this.castleRookQueenSide(specialMoveSquare);
                }
                else if (specialMoveSquare === this.chessboard.getEastCastlingSquare()) {
                    this.castleRookKingSide(specialMoveSquare);
                }
            }
            if (specialMoveSquare.isEnPassantSquare()) {
                this.performEnPassantCapture(specialMoveSquare);
            }
        }
    }
    performEnPassantCapture(square) {
        const capturedEnPassantSquare = this.gameLogic.performEnPassantCapture(square);
        this.setSpecialMoveSquare(capturedEnPassantSquare);
    }
    castleRookQueenSide(square) {
        const squaresArray = this.chessboard.getSquaresArray();
        const queenSideRookSquareIndex = this.gameLogic.castleRookQueenSide(square);
        this.setSpecialMoveSquare(squaresArray[queenSideRookSquareIndex]);
    }
    castleRookKingSide(square) {
        const squaresArray = this.chessboard.getSquaresArray();
        const kingSideRookSquareIndex = this.gameLogic.castleRookKingSide(square);
        this.setSpecialMoveSquare(squaresArray[kingSideRookSquareIndex]);
    }
    postMoveCalculations() {
        if (this.player.isDemonstrationMode() && this.player.hasCompletedTurn()) {
            this.switchPlayerForDemonstrationMode();
        }
        const enPassantSquare = this.gameState.getFenString().split(" ")[3];
        this.gameLogic.determineEnPassantSquare(enPassantSquare);
        this.gameLogic.determineAttackedSquares();
        this.setPlayerCompletedTurn(false);
        this.determineGameConditions();
    }
    determineGameConditions() {
        const validMoves = this.gameData.getNumberOfValidMoves();
        if (validMoves === 0) {
            if (this.player.isInCheck()) {
                console.log('checkmate');
                // checkmate
            }
            else {
                console.log('stalemate');
                // stalemate
            }
            this.setGameOver(true);
        }
        else if (this.gameState.getHalfmoveClock() === 50) {
            console.log('draw');
            // draw
            this.setGameOver(true);
        }
    }
    isDemonstrationMode() { return this.player.isDemonstrationMode(); }
    isMultiplayerGame(nextPlayerTurn) { return nextPlayerTurn === this.getCurrentPlayer().getColour(); }
    incrementMoveCount(piece) { piece.incrementMoveCount(); }
    removeSpecialSquare() { delete this.specialMoveSquare; }
    clearAttackedSquares() { this.gameData.clearAttackedSquares(); }
    requestedMoveIsValid(squares) { return this.gameLogic.checkRequestedMove(squares); }
    squareIsActive() { return this.isSquareClicked; }
    specialMoveInProgress() { return this.specialMoveInitiated; }
    pawnIsBeingMoved() { return this.pawnBeingMoved; }
    pieceIsBeingCaptured() { return this.pieceBeingCaptured; }
    gameIsOver() { return this.gameOver; }
    getNextMove() { return (this.gameState.getCurrentTurn() === "White" ? "Black" : "White"); }
    getAttackedSquares() { return this.gameData.getAttackedSquares(); }
    getGameState() { return this.gameState; }
    getChessboard() { return this.chessboard; }
    getCurrentPlayer() { return this.player; }
    getSpecialMoveSquare() { return this.specialMoveSquare; }
    setSpecialMoveSquare(move) { this.specialMoveSquare = move; }
    setSquareActive(active) { this.isSquareClicked = active; }
    setSpecialMoveInProgress(moving) { this.specialMoveInitiated = moving; }
    setPawnIsBeingMoved(moving) { this.pawnBeingMoved = moving; }
    setPieceIsBeingCaptured(captured) { this.pieceBeingCaptured = captured; }
    setPlayerCompletedTurn(completed) { this.player.setTurnComplete(completed); }
    setGameOver(gameOver) { this.gameOver = gameOver; }
}

const boardSize = () => { return ((window.innerWidth > window.innerHeight)); };
var ClickSquare;
(function (ClickSquare) {
    ClickSquare[ClickSquare["select"] = 1] = "select";
    ClickSquare[ClickSquare["deselect"] = 0] = "deselect";
})(ClickSquare || (ClickSquare = {}));
class GameCanvas extends React__default.Component {
    constructor(props) {
        super(props);
        this.canvas = React__default.createRef();
        this.width = (boardSize() ? window.innerWidth : window.innerHeight) / 2.5;
        this.height = this.width;
        this.ratio = this.width / this.height;
        this.resizeCallback = () => setTimeout(this.update, 500);
        this.update = this.update.bind(this);
        this.state = {
            canvas: this.canvas,
            screen: {
                width: this.height * (this.width / this.height),
                height: this.width,
                ratio: this.ratio
            }
        };
        if (this.props.controller) {
            this.props.controller.bind(this.props.game);
        }
        this.game = new Game(this.props.player, this.props.game.nextFenString, this.props.game.nextPlayerTurn);
    }
    initialise() {
        const { cw, ch } = this.getCellDimensions();
        this.game.initialise(cw, ch);
        this.drawBoard();
        this.drawPieces();
    }
    componentDidMount() {
        this.initialise();
        window.addEventListener('resize', this.resizeCallback, false);
        this.state.canvas.current.addEventListener("click", (event) => { this.interceptClick(event); }, false);
    }
    componentWillUnmount() { }
    componentDidUpdate() {
        if (this.props.resetGame) {
            this.resetGame();
            return;
        }
        if (this.game.isMultiplayerGame(this.props.game.nextPlayerTurn)) {
            this.updateOpponentMove();
        }
        this.game.postMoveCalculations();
    }
    resetGame() {
        this.game = new Game(this.props.player, this.props.game.nextFenString, this.props.game.nextPlayerTurn);
        this.initialise();
        this.drawBoard();
        this.drawPieces();
    }
    updateOpponentMove() {
        const updatedSquare = this.game.updateGameState(this.props.game);
        if (updatedSquare) {
            this.handleOpponentMove(updatedSquare);
        }
    }
    update() {
        this.width = (boardSize() ? window.innerWidth : window.innerHeight) / 2.5;
        this.height = this.width;
        this.setState({
            canvas: this.canvas,
            screen: {
                width: this.height * (this.width / this.height),
                height: this.height,
                ratio: this.ratio
            }
        });
        this.updateBoardSize();
    }
    updateBoardSize() {
        const { cw, ch } = this.getCellDimensions();
        this.game.updateSquareSizeProps(cw, ch);
        this.drawBoard();
        this.drawPieces();
    }
    drawBoard() {
        const ctx = this.state.canvas.current.getContext('2d');
        ctx.fillStyle = '#FFF';
        ctx.fillRect(0, 0, this.state.screen.width, this.state.screen.height);
        let rank = 0;
        for (let i = 0; i < this.game.getChessboard().getSquaresArray().length; i++) {
            const x = this.game.getChessboard().getSquaresArray()[i].getX();
            const y = this.game.getChessboard().getSquaresArray()[i].getY();
            const w = this.game.getChessboard().getSquaresArray()[i].getWidth();
            const h = this.game.getChessboard().getSquaresArray()[i].getHeight();
            if (i % 8 === 0) {
                rank++;
            }
            this.setSequareColours(i, rank, ctx);
            ctx.strokeRect(x, y, w, h);
            ctx.fillRect(x, y, w, h);
        }
    }
    setSequareColours(i, rank, ctx) {
        if ((i + rank) % 2 === 0) {
            ctx.strokeStyle = '#1a1a1a';
            ctx.fillStyle = '#f2f2f2';
            this.game.getChessboard().getSquaresArray()[i].setColour('#f2f2f2');
        }
        else {
            ctx.strokeStyle = '#f2f2f2';
            ctx.fillStyle = '#1a1a1a';
            this.game.getChessboard().getSquaresArray()[i].setColour('#1a1a1a');
        }
    }
    drawPieces() {
        const squaresArray = this.game.getChessboard().getSquaresArray();
        const files = this.game.getChessboard().getFiles();
        const ranks = this.game.getChessboard().getRanks();
        squaresArray.forEach((square, index) => {
            if (square.getPiece()) {
                const piece = square.getPiece();
                const position = piece.getPosition().split("");
                const img = new Image();
                img.src = piece.getImage();
                img.id = piece.getType();
                this.drawImg(img, ranks.indexOf(Number(position[1])), files.indexOf(position[0]));
            }
        });
    }
    drawImg(img, file, rank) {
        const ctx = this.state.canvas.current.getContext('2d');
        const { cw, ch } = this.getCellDimensions();
        if (!img.complete) {
            setTimeout(() => { this.drawImg(img, file, rank); }, 50);
        }
        if (img.id === 'P' || img.id === 'p') {
            ctx.drawImage(img, (cw * rank) + cw * 0.2, (ch * file) + ch * 0.1, cw * 0.6, ch * 0.8);
        }
        else {
            ctx.drawImage(img, (cw * rank) + cw * 0.1, (ch * file) + ch * 0.1, cw * 0.8, ch * 0.8);
        }
    }
    interceptClick(event) {
        if ((this.game.getGameState().getCurrentTurn() === this.game.getCurrentPlayer().getColour()) && !this.game.gameIsOver()) {
            this.determineClick(event);
        }
    }
    determineClick(event) {
        const cx = event.offsetX;
        const cy = event.offsetY;
        const squaresArray = this.game.getChessboard().getSquaresArray();
        for (let i = 0; i < squaresArray.length; i++) {
            const sx = squaresArray[i].getX();
            const sy = squaresArray[i].getY();
            const sw = squaresArray[i].getWidth();
            const sh = squaresArray[i].getHeight();
            if (cx >= sx && cx <= sx + sw && cy >= sy && cy <= sy + sh) {
                this.handleClick(squaresArray[i]);
            }
        }
    }
    handleClick(clickedSquare) {
        if (this.game.squareIsActive()) {
            if (this.game.getChessboard().getActiveSquare() === clickedSquare) {
                this.selectSquare(clickedSquare, ClickSquare.deselect);
            }
            else if (this.game.getChessboard().getActiveSquare() !== clickedSquare) {
                this.handlePlayerMove(clickedSquare);
            }
            return;
        }
        if (clickedSquare.squareContainsPiece()) {
            if (clickedSquare.getPiece().getColour() === this.game.getCurrentPlayer().getColour()) {
                this.selectSquare(clickedSquare, ClickSquare.select);
            }
        }
    }
    handlePlayerMove(attackedSquare) {
        if (!this.game.requestedMoveIsValid(attackedSquare)) {
            return;
        }
        this.game.determinePlayerSpecialMoveCase(attackedSquare);
        if (this.game.specialMoveInProgress()) {
            this.handleSpecialSquare(attackedSquare);
        }
        this.processPlayerMove(attackedSquare);
    }
    processPlayerMove(attackedSquare) {
        const prevActiveSquarePos = this.game.getChessboard().getActiveSquare().getPosition();
        const nextActiveSquarePos = attackedSquare.getPosition();
        this.game.setSquareActive(false);
        this.game.preMoveProcessing(attackedSquare);
        this.overwriteSquare(attackedSquare);
        this.game.postMoveProcessing();
        this.setNextState(prevActiveSquarePos, nextActiveSquarePos);
    }
    handleOpponentMove(updatedSquare) {
        const activeSquarePos = this.game.getChessboard().getActiveSquare().getPosition();
        const activePiece = this.game.getChessboard().getActiveSquare().getPiece();
        this.game.checkValidMoves(activeSquarePos, activePiece);
        this.game.determinePlayerSpecialMoveCase(updatedSquare);
        if (this.game.specialMoveInProgress()) {
            this.handleSpecialSquare(updatedSquare);
        }
        this.overwriteSquare(updatedSquare);
    }
    handleSpecialSquare(attackedSquare) {
        this.game.checkSpecialMoves(attackedSquare);
        const oldSquare = this.game.getSpecialMoveSquare();
        this.selectCell(oldSquare);
        this.game.setSpecialMoveInProgress(false);
        this.game.removeSpecialSquare();
    }
    selectSquare(activeSquare, instruction) {
        const files = this.game.getChessboard().getFiles();
        const ranks = this.game.getChessboard().getRanks();
        const activePiece = activeSquare.getPiece();
        const img = this.constructImage(activePiece);
        instruction === ClickSquare.select ? this.game.handleActivatedSquare(activeSquare) : this.game.handleDeactivatedSquare();
        this.manageValidSquares();
        this.selectCell(activeSquare);
        this.drawImg(img, ranks.indexOf(Number(activeSquare.getPosition()[1])), files.indexOf(activeSquare.getPosition()[0]));
    }
    overwriteSquare(activeSquare) {
        const files = this.game.getChessboard().getFiles();
        const ranks = this.game.getChessboard().getRanks();
        const prevActiveSquare = this.game.getChessboard().getActiveSquare();
        const activePiece = prevActiveSquare.getPiece();
        const img = this.constructImage(activePiece);
        this.game.handleOverwriteSquare(activeSquare, activePiece);
        this.selectCell(prevActiveSquare);
        this.manageValidSquares();
        this.selectCell(activeSquare);
        this.drawImg(img, ranks.indexOf(Number(activeSquare.getPosition()[1])), files.indexOf(activeSquare.getPosition()[0]));
    }
    manageValidSquares() {
        if (this.game.squareIsActive()) {
            const activeSquarePos = this.game.getChessboard().getActiveSquare().getPosition();
            const activePiece = this.game.getChessboard().getActiveSquare().getPiece();
            this.game.checkValidMoves(activeSquarePos, activePiece);
            this.drawValidSquares();
            return;
        }
        this.drawValidSquares();
        this.game.clearAttackedSquares();
    }
    drawValidSquares() {
        if (this.game.getAttackedSquares().length > 0) {
            const validMoves = this.game.getAttackedSquares();
            for (let i = 0; i < validMoves.length; i++) {
                this.highlightValidSquares(validMoves[i]);
            }
        }
    }
    highlightValidSquares(validSquare) {
        const files = this.game.getChessboard().getFiles();
        const ranks = this.game.getChessboard().getRanks();
        this.selectCell(validSquare);
        if (validSquare.squareContainsPiece()) {
            const img = this.drawPiece(validSquare.getPiece());
            this.drawImg(img, ranks.indexOf(Number(validSquare.getPosition()[1])), files.indexOf(validSquare.getPosition()[0]));
        }
    }
    constructImage(activeSquare) {
        const img = new Image();
        img.src = activeSquare.getImage();
        img.id = activeSquare.getType();
        return img;
    }
    drawPiece(validMoves) {
        const img = new Image();
        img.id = validMoves.getType();
        img.src = validMoves.getImage();
        return img;
    }
    selectCell(square) {
        const ctx = this.state.canvas.current.getContext('2d');
        const sx = square.getX();
        const sy = square.getY();
        const sw = square.getWidth();
        const sh = square.getHeight();
        if (this.game.squareIsActive() && !this.game.specialMoveInProgress()) {
            ctx.fillStyle = '#6F9EFF';
        }
        else {
            ctx.fillStyle = square.getColour();
        }
        ctx.strokeRect(sx, sy, sw, sh);
        ctx.fillRect(sx, sy, sw, sh);
    }
    setNextState(prevPos, nextPos) {
        this.game.setPlayerCompletedTurn(true);
        const nextPlayerMove = this.game.getNextMove();
        this.game.getGameState().setCurrentTurn(this.game.getNextMove());
        const newFenSequence = this.game.createFenString();
        this.game.getGameState().setFenString(newFenSequence);
        this.game.getGameState().setMoveState(prevPos, nextPos);
        if (this.props.controller) {
            const newState = {
                nextFenString: newFenSequence,
                nextPlayerTurn: nextPlayerMove,
                movePieceFrom: prevPos,
                movePieceTo: nextPos
            };
            this.props.controller(newState);
        }
    }
    render() {
        return (React__default.createElement("canvas", { id: "canvas", ref: this.state.canvas, width: this.state.screen.width * this.state.screen.ratio, height: this.state.screen.height * this.state.screen.ratio }));
    }
    getCellDimensions() {
        const cw = (this.state.screen.width * this.state.screen.ratio) / 8;
        const ch = (this.state.screen.height * this.state.screen.ratio) / 8;
        return { cw, ch };
    }
}

const App = () => {
    return (React__default.createElement("div", { id: "unichess-heading" },
        React__default.createElement("h1", null, "Cyn1x Chess Engine")));
};

ReactDOM.render(React__default.createElement(App, null), document.getElementById("root"));

exports.Canvas = GameCanvas;
//# sourceMappingURL=index.js.map
