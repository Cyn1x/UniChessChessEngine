import { IPiece } from '../entities/pieces/types';
import GameData from '../GameData';
import Board from '../entities/Board';
import Square from '../entities/Square';
import Player from '../entities/Player';
declare class GameLogic implements Logic {
    private gameData;
    private chessboard;
    private specialMoves;
    private player;
    private verifyingKingCheckState;
    private verifyingNewMoveState;
    private verifyingBoardState;
    private verifyingOpponentState;
    private moveContainsCheck;
    constructor(gameData: GameData, chessboard: Board);
    checkRequestedMove(attackedSquare: Square): true | undefined;
    checkSpecialMove(specialMoveSquare: Square): Square | undefined;
    checkMoveSideEffects(activeSquare: Square, attackedSquare: Square): void;
    squareContainsAttack(piece: IPiece): void;
    determineMoveCase(piece: IPiece): void;
    determineGeneralMoveCases(piece: IPiece, pieceMoveDirections: Map<string, number>): void;
    determineKnightSpecialCases(piece: IPiece, pieceMoveDirections: Map<string, number>): void;
    checkAttackableSquares(file: number, rank: number, piece: IPiece): boolean | undefined;
    squareContainsPiece(piece: IPiece, attackedSquare: Square): boolean | undefined;
    determinePlayerInCheck(piece: IPiece, attackedSquare: Square): void;
    attackUnoccupiedSquares(piece: IPiece, attackedSquare: Square): boolean | undefined;
    attackOccupiedSquares(piece: IPiece, attackedSquare: Square): false | undefined;
    setSquareAttack(attackedSquare: Square, piece: IPiece): void;
    checkKingDefences(attackedSquare: Square): void;
    moveContainsCheckDeterminant(piece: IPiece): void;
    kingBeingOpenedForAttack(kingPiece: IPiece, attackedSquare: Square): true | void;
    determineDiagonalAttackingPiece(kingPiece: IPiece, attackedSquare: Square): true | void;
    rookIsAttackingKing(kingPiece: IPiece, attackedSquare: Square): true | undefined;
    queenIsAttackingKing(kingPiece: IPiece, attackedSquare: Square): true | undefined;
    bishopIsAttackingKing(kingPiece: IPiece, attackedSquare: Square): true | undefined;
    knightIsAttackingKing(kingPiece: IPiece, attackedSquare: Square): true | undefined;
    pawnIsAttackingKing(kingPiece: IPiece, attackedSquare: Square): void;
    kingCanEscapeCheck(kingPiece: IPiece, attackedSquare: Square): boolean;
    kingInCheck(piece: IPiece, attackedPiece: IPiece): boolean | undefined;
    determineAttackedSquares(): void;
    playerCanCastleDeterminant(piece: IPiece): void;
    performEnPassantCapture(captureSquare: Square): Square;
    determineEnPassantSquare(squarePosition: string): void;
    castleRookQueenSide(queenSideSquare: Square): number;
    castleRookKingSide(kingSideSquare: Square): number;
    calculateArrayIndex(file: number, rank: number): number;
    squaresLineUp(firstSquareFile: number, firstSquareRank: number, secondSquareFile: number, secondSquareRank: number): boolean;
    isPawn(piece: IPiece): boolean;
    isBishop(piece: IPiece): boolean;
    isKnight(piece: IPiece): boolean;
    isRook(piece: IPiece): boolean;
    isQueen(piece: IPiece): boolean;
    isKing(piece: IPiece): boolean;
    isVerifyingKingCheckState(): boolean;
    isVerifyingNewMoveState(): boolean;
    isVerifyingNewBoardState(): boolean;
    isVerifyingOpponentState(): boolean;
    newMoveContainsCheck(): boolean;
    pawnCanAttack(square: Square, piece: IPiece): boolean;
    getPlayerForMoveValidation(): Player;
    setPlayerForMoveValidation(player: Player): void;
    setVerifyingKingCheckState(verifying: boolean): void;
    setVerifyingNewMoveState(verifying: boolean): void;
    setVerifyingNewBoardState(verifying: boolean): void;
    setVerifyingOpponentState(verifying: boolean): void;
    setNewMoveContainsCheck(check: boolean): void;
}
export default GameLogic;
